##   0、讲一下redis（特点、优点）



![image-20230621214102755](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230621214102755.png)



## 0.1、为什么把redis用作mysql的缓存？

主要是因为 **Redis 具备「高性能」和「高并发」两种特性**

***1、Redis 具备高性能***

假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

***2、 Redis 具备高并发***

单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破  1w。

所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

# 一、redis 线程模型

## 1.1、 redis是单线程吗？

主线程是单线程

但是在redis开启的时候会开启后台线程，用于处理AOF刷盘操作、删除内存、关闭文件等操作



## 1.2、说redis是单线程是什么意思？

![image-20230621214314256](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230621214314256.png)

## 1.3、redis为什么快？

> （1）基于内存（最重要的原因），并且内置了多种优化之后的数据结构
>
> （2）主线程是单线程，不会有线程之间的竞争以及切换
>
> （3）采用**io多路复用**来处理客户端的请求



## 1.4 redis主线程为什么要采用单线程？

（1）redis处理的瓶颈并不在cpu上，而在**内存大小**和网络I/O的限制上

（2）多线程切换会导致不必要的资源损耗

（3）多线程环境下会存在线程安全等问题，必然需要使用锁来解决，使用锁又有可能造成死锁等问题，会造成性能的下降

## 1.5 Redis 6.0 之后为什么引入了多线程？

这里说的引入多线程是指 网络IO部分采用多线程来处理

主业务还是单线程【**接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**】

**这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上**。

## 1.6 redis 网络模型



# 二、redis 数据结构

redis提供了多种数据结构

常见的有五种数据类型：**String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）**

## 1、Redis 五种数据类型的应用场景

- String 类型的应用场景：缓存对象、常规计数、**利用 `SETNX key value` 命令可以实现一个最简易的分布式锁**、共享 session 信息等。
- List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- Hash 类型：缓存对象、购物车等。
- Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

## 2、Redis 底层数据结构

![img](https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png)

### 2.1 为什么redis的底层使用SDS？

【[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)O（1）复杂度获取字符串长度、[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)二进制安全、[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)不会发生缓冲区溢出、[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)节省内存空间】

（1）因为c语言中的字符串是以`“\0”`作为结束标志的，假设有个字符串中有个 `“\0”` 字符，这时在操作这个字符串时就会**提早结束**，这就导致字符串没法存储像视频、音频等二进制数据。**SDS中有一个len属性的值，来判断字符串是否结束的**，并且SDS所有的API都是**以处理二进制的方式来处理储存的数据的**。获取字符串长度的时间复杂度是o(1)。

（2）**C 语言的字符串是不会记录自身的缓冲区大小的**，SDS的API是安全的，字符串拼接不会出现溢出，【会先判断】

Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 `alloc - len` 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。

而且，**当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小**，以满足修改所需的大小。

（3）**SDS 设计不同类型的结构体，能灵活保存不同大小的字符串，从而有效节省内存空间**

除了设计不同类型的结构体，Redis 在编程上还**使用了专门的编译优化来节省内存空间**，即在 struct 声明了 `__attribute__ ((packed))` ，它的作用是：**告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐**。



##  SDS

![img](https://cdn.xiaolincoding.com//mysql/other/516738c4058cdf9109e40a7812ef4239.png)



- **len，记录了字符串长度**。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
- **alloc，分配给字符数组的空间长度**。这样在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。
- **flags，用来表示不同类型的 SDS**。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，**SDS 设计不同类型的结构体，能灵活保存不同大小的字符串，从而有效节省内存空间**。
- **buf[]，字符数组，用来保存实际数据**。

> ###   为什么redis的底层使用SDS？

【[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)O（1）复杂度获取字符串长度、[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)二进制安全、[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)不会发生缓冲区溢出、[#](https://www.xiaolincoding.com/redis/data_struct/data_struct.html#o-1-复杂度获取字符串长度)节省内存空间】

（1）因为c语言中的字符串是以`“\0”`作为结束标志的，假设有个字符串中有个 `“\0”` 字符，这时在操作这个字符串时就会**提早结束**，这就导致字符串没法存储像视频、音频等二进制数据。**SDS中有一个len属性的值，来判断字符串是否结束的**，并且SDS所有的API都是**以处理二进制的方式来处理储存的数据的**。获取字符串长度的时间复杂度是o(1)。

（2）**C 语言的字符串是不会记录自身的缓冲区大小的**，SDS的API是安全的，字符串拼接不会出现溢出，【会先判断】

Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 `alloc - len` 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。

而且，**当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小**，以满足修改所需的大小。

（3）**SDS 设计不同类型的结构体，能灵活保存不同大小的字符串，从而有效节省内存空间**

除了设计不同类型的结构体，Redis 在编程上还**使用了专门的编译优化来节省内存空间**，即在 struct 声明了 `__attribute__ ((packed))` ，它的作用是：**告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐**。

## Dict

底层数据结构以及对应的设计--->扩容--->存在的问题--->改进的方案

Dict是由 哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）3部分组成。

Dict中有两个指针指向了两个hashTable，其中一个是用来存储数据的，另外一个是空的。

存储数据的HashTable中有四个重要的字段。size记录了Entry数组的总长度、sizeMask记录了entry数组长度－1，used记录HashTable中已经存入的数据的个数。

DictEntry 用来存储数据，dictEntry之间通过链表连接起来，是一个单链表

![image-20231028150115856](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20231028150115856.png)



- 用key计算出来的hash值与sizemask做**与操作**，得到哈希桶的桶号 ，它**能以 O(1) 的复杂度快速查询数据**。
- Redis 采用了**「链式哈希」**来解决哈希冲突**。实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表，**被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来，这样就解决了哈希冲突。

- Redis 定义一个 dict 结构体，这个结构体里定义了**两个哈希表（ht[2]）**，其中一个哈希表是空的。是用来扩容的，Dict在每次新增键值对的时候 都会检查是否要扩容 。

  - 触发 rehash 操作的条件，主要有两个：

    - **当负载因子大于等于 1（used/sized） ，并且没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。**
    - **当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作**
- **rehash的步骤：**
  
  - 给「哈希表 1」 分配空间，一般会比「哈希表 0」 大 2 倍；
    - 将「哈希表0」的数据全部迁移到「哈希表1」 中；
    - 迁移完成后，「哈希表0 」的空间会被释放，并把「哈希表0」 的table指针指向「哈希表 1」指向的table，然后在「哈希表 1」 新创建一个空白的哈希表，为下次 rehash 做准备.
  - 存在的风险：

    - **如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求**。因为**Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**，这也是我们常说 Redis 是单线程的原因。
- 解决方案 :**渐进式 rehash**
  -  Redis 采用了**渐进式 rehash**，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。
  
  - 步骤:
  
    - 给「哈希表 2」 分配空间；
  
    - **在 rehash 进行期间，【每次哈希表元素进行新增、删除、查找或者更新操作时】，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上**；
    - 随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。
      - 对于新增操作 ： 在哈希表2
    - 对于查询、删除、修改 ：需要在两个表中进行，



## ZipList

Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。这意味着Redis一定是非常精细地考虑了压缩数据、减少内存碎片等问题。

压缩列表是 Redis 为了节约内存而开发的，它是**由【连续内存块】组成的【顺序型数据结构】**，有点类似于数组。

![img](https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png)

**![image-20231028192830512](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20231028192830512.png)**

压缩列表在表头有三个字段：

- ***zlbytes***，记录整个压缩列表占用内存的字节数；
- ***zltail***，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
- ***zllen***，记录压缩列表包含的节点数量；
- ***zlend***，标记压缩列表的结束点，固定值 0xFF（十进制255）。

压缩列表节点包含三部分内容：

- ***prevlen***，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；
- ***encoding***，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。
- ***data***，记录了当前节点的实际数据，类型和长度都由 `encoding` 决定；

当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，使用不同空间大小的 prevlen 和 encoding 来保存信息。**例如 ：**

- 如果**前一个节点的长度小于 254 字节**，那么 prevlen 属性需要用 **1 字节的空间**来保存这个长度值；
- 如果**前一个节点的长度大于等于 254 字节**，那么 prevlen 属性需要用 **5 字节的空间**来保存这个长度值；

encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关

- 如果**当前节点的数据是整数**，则 encoding 会使用 **1 字节的空间**进行编码
- 如果**当前节点的数据是字符串，根据字符串的长度大小**，encoding 会使用 **1 字节/2字节/5字节的空间**进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。



存在的问题 ：查找中间元素的复杂度很高、适用于存储少量元素的场景，连锁更新。

### 连锁更新

压缩列表除了查找复杂度高的问题，还有一个问题。

**压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降**。

- 解决办法 ：quicklist 。【**通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题】。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。**

## QuickList

quicklist 就是**「双向链表 + 压缩列表」组合**，**因为一个 quicklist 就是一个双向链表，而链表中的每个元素又是一个压缩列表。**

- **双向链表**便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。
- **ziplist**由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。

于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。

- 每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。
- 每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了



一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数`list-max-ziplist-size`，就是为了让使用者可以来根据自己的情况进行调整。



当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数`list-compress-depth`就是用来完成这个设置的。

quickList的结构如下：

![img](http://zhangtielei.com/assets/photos_redis/redis_quicklist_structure.png)

**QuickList的操作**

在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。

quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。



## SkipList

本质上是链表、**跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表**

- 跳表中的元素按照升序排列存储，
- **一个节点可能包含多个指针，指针跨度不同。**

- 跳表的优势是能支持平均 O(logN) 复杂度的节点查找。





# 三 、redis 用作缓存

## 0、为什么把redis用作mysql的缓存？

主要是因为 **Redis 具备「高性能」和「高并发」两种特性**

***1、Redis 具备高性能***

假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

***2、 Redis 具备高并发***

单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破  1w。

所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

## 1、redis 用作缓存的作用

（1）降低数据库的压力

（2）提高数据的读写效率，降低响应时间

## 2、 redis 用作缓存带来的问题

（1）数据库和缓存数据不一致

（2）缓存穿透、缓存击穿、缓存雪崩

（3）维护的成本会增大

## 3、 缓存作用的模型

redis用作缓存很简单，存取读和更新缓存。

读取数据的时候，先去缓存中进行查找，在缓存中没有命中在去查询数据库，再将数据写入到缓存中。

![image-20230702201107149](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230702201107149.png)

## 4、 缓存更新策略

- **缓存更新的策略有3种：** 内存淘汰、超时剔除、主动更新
  - ***内存淘汰机制：***	不用自己维护，当redis内存不足的时候会自动淘汰一些数据，下次查询的时候再更新缓存。在一定程度上可以保证数据的一致性。
  - ***超时剔除：***给数据设置存活时间，到了时间自动删除缓存，下次查询的时候从数据库中读取到redis中。
  - ***主动更新：*****就是在处理业务逻辑的修改数据库的时候自动更新缓存**。
    - 旁路缓存策略 ： **由缓存的调用者，在更新数据库的同时更新缓存**。

### 4.1什么是缓存更新？

> 就是更新缓存中的数据以保证和源数据库中数据的一致性。

### 4.2什么时候需要缓存更新？

> 就是源数据库中的数据发生改变时，需要更新缓存，以保证数据库和缓存的数据一致性

### 4.3 主动更新要考虑的三个问题

- **是删除缓存还是更新缓存、先删除缓存还是先更新数据库，如何保证这两个操作的原子性**

  - **是删除缓存还是更新缓存？**

    - 更新缓存 ： 更新数据库时都更新缓存，在写操作很多的时候，缓存的更新无效。
    - 删除缓存：更新数据库的时候让缓存无效，查询时再更新缓存。

  - **如何保证这两个操作的原子性?**

    - 单体 ： 利用事务本身的特性，将缓存和数据库操作放在一个事务里
    - 分布式：分布式事务

  - **先删除缓存还是先更新数据库**？

    先操作数据库，再删除缓存

  将删除缓存和更新数据库这两个操作分别处理，并采用其他方法（分布式锁、消息队列）来保证它们的一致性

### 4.4  介绍一下项目中采用的主动更新策略（缓存与数据库数据一致性如何保证？）



## 5、 缓存穿透

缓存穿透是指客户端请求的数据在**缓存中和数据库中**都不存在，这样缓存永远不会有效，这些请求都会打到数据库。

- #### **常见的解决方法有**

  - 缓存空对象

    

  - 使用布隆过滤器

    


## 6、缓存击穿

如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是**缓存击穿**的问题。

- #### **常见的解决方法有**

  - 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
  - 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；



## 7、缓存雪崩

- 当**【大量缓存数据在同一时间过期（失效）时，如果此时有大量的用户请求，都无法在 Redis 中处理】，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成【数据库宕机】，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩**的问题。

  - 大量数据同时过期；
  - Redis 故障宕机；

- #### 解决方法 -大量数据同时过期

  - 设置过期时间的时候加上一个随机数
  - 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
  - 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；

## 8、布隆过滤器是什么？

- 是一个二进制数组和多个哈希函数组成的一个数据结构，可以用于快速地判断一个值是否处于某个集合当中









### 一 、 内存回收机制

#### 1、Redis过期键的删除策略有哪些？

**惰性删除**、**定时删除**、**定期删除**

#### 2、Redis删除策略的优点和缺点有哪些？

>  **惰性删除**、**定时删除**、**定期删除**
>
> ***惰性删除***是指过期的时候先不删除，等下次再访问这个key的时候再删除
>
> > 过程 ： 客户端发送请求访问某个key ，如果可以key 不存在则返回null/ 空结果
> >
> > 如果key存在，则来判断key是否过期，如果过期则返回null/空结果，如果没有过期则将key对应的value返回
>
> ***定时删除***是指设置过期时间的同时创建一个定时器，让定时器在过期时间到来之时立即删除key
>
> ***定期删除***是指定期（默认是1s）抽取key来判断key是否过期，又分为两种策略（slow 和fast）
>
> 实际使用中是 ：惰性删除和定期删除两种结合
>
> 优缺点
>
> 惰性删除： 
>
> ​				优： 对cpu友好，不会将cpu耗费在无关紧要的地方
>
> ​				缺：可能存在一些键长期或者永远不会被删除
>
> 定时删除：
>
> ​				优：能够及时删除过期key，释放内存空间
>
> ​				缺：如果有大量key过期的话会占掉一部分cpu资源，降低了响应速率
>
> 定期删除：
>
> ​				优：对cpu友好
>
> ​				缺：频率不是很好控制，过期键可能没法及时删除

#### 3、内存淘汰机制

八种



#### 4、lru是怎样的过程？

lru ： 是最少最近使用内存淘汰算法

因为redis每个数据都会封装为redisObject，RedisObject有一个属性 lru ，每一次访问数据，都会将redisObject中的lru更新为当前的时间戳。用当前时间-最近使用时间都知道哪个是最少最近使用的数据，将其淘汰这就是lru

当客户端给redis发送写请求的时候，redis会先去判断自己的内存是否足够，当发现内存不够是就要进行内存淘汰，当内存淘汰机制是lru的时候，（其实redis使用的是一种近似lru算法） 第一次随机抽取5个key，按照nowtime-lru 的值升序放入池子中，当第二次抽取key时将nowtime-lur值比池子中最大的lur值还要大的key放入池子中，当池子满了时，在池子里面选择值最大的那个key进行淘汰（实则pool是有序的 ）。如果内存还不够就再重复这个过程

![image-20230514163452754](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514163452754.png)



# 二、 redis 用作缓存 

## 1、Redis除了缓存商家信息还缓存了什么？

- 缓存了过期的token 、给登录过的用户设置的密钥

- redis 除了缓存商家信息，还可以缓存token，热key，缓存预热

## 2、 redis用作缓存的优缺点？

- 优： 读写速度快，减轻数据库的压力，（服务器分布式、集群情况下解决session共享问题）

- 缺： 造成 缓存雪崩，缓存击穿，缓存穿透 和数据库和redis缓存数据不一致等等问题

## 3、redis 用作缓存的使用方法（缓存作用模型）



![image-20230702204744027](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230702204744027.png)

## 4、缓存更新的策略

- **缓存更新的策略有3种：** 内存淘汰、超时剔除、主动更新
  - ***内存淘汰机制：***	不用自己维护，当redis内存不足的时候会自动淘汰一些数据，下次查询的时候再更新缓存。在一定程度上可以保证数据的一致性。
  - ***超时剔除：***给数据设置存活时间，到了时间自动删除缓存，下次查询的时候从数据库中读取到redis中。
  - ***主动更新：***就是在处理业务逻辑的修改数据库的时候自动更新缓存。
    - 旁路缓存策略 ： **由缓存的调用者，在更新数据库的同时更新缓存**。

### 4.1什么是缓存更新？

> 就是更新缓存中的数据以保证和源数据库中数据的一致性。

### 4.2什么时候需要缓存更新？

> 就是源数据库中的数据发生改变时，需要更新缓存，以保证数据库和缓存的数据一致性

### 4.3 主动更新要考虑的三个问题

- **是删除缓存还是更新缓存、先删除缓存还是先更新数据库，如何保证这两个操作的原子性**

  - **是删除缓存还是更新缓存？**

    - 更新缓存 ： 更新数据库时都更新缓存，在写操作很多的时候，缓存的更新无效。
    - 删除缓存：更新数据库的时候让缓存无效，查询时再更新缓存。

  - **如何保证这两个操作的原子性?**

    - 单体 ： 利用事务本身的特性，将缓存和数据库操作放在一个事务里
    - 分布式：分布式事务

  - **先删除缓存还是先更新数据库**？

    先操作数据库，再删除缓存

  将删除缓存和更新数据库这两个操作分别处理，并采用其他方法（分布式锁、消息队列）来保证它们的一致性，

>  **主动更新缓存的策略 ：** 
>
> ​				**先删除缓存再更新数据库，下次访问的时候再更新缓**存
>
> ![https://img-blog.csdnimg.cn/04993fdc822e4d8babfe39c8039a0005.png](https://img-blog.csdnimg.cn/04993fdc822e4d8babfe39c8039a0005.png)
>
> 
>
> ![img](https://img-blog.csdnimg.cn/9746f0d54ee04afca11d4814228f51f2.png)
>
> 
>
> 
>
> ​				**先更新数据库再删除缓存，下次访问的时候再更新缓存**
>
> ![img](https://img-blog.csdnimg.cn/f7618a41e24b44a3b008e5baf3f36653.png)
>
> ![img](https://img-blog.csdnimg.cn/adc4ad43587b40d4a8076db25abecff2.png)			
>
> 
>
> ​	**延时双删，先删除缓存，再更新数据库，线程sleep(),再次删除缓存**
>
> **读写分离怎么办？**  （此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进⾏查询。）
>
> ![img](https://img-blog.csdnimg.cn/a4e3839ff0da46ceaa941adcfaeb9e10.png)
>
> ​	



#### 5、缓存与数据库数据一致性如何保证？

> 将删除缓存和更新数据库这两个操作分别处理，并采用其他方法来保证它们的一致性，比如使用消息队列、分布式锁等机制，
>
> **想要保证数据库和redis的数据一致性有四种策略 ：**
>
> ​			1、先更新数据库再删除缓存
>
> ​				如果缓存删除失败了，此时B线程来访问redis就会读到旧数据
>
> ​				如果缓存删除成功，有可能在线程A删除缓存之前线程B就读到了redis中旧数据（分布式锁）
>
> ​			2、先删除缓存再更新数据库
>
> ​			更新数据库失败，会读到旧数据
>
> ​			更新数据库成功，有可能在线程A更新数据库之前线程B就读到了数据库中旧数据（分布式锁）
>
> -------这两中方法都存在问题，可以用分布式锁或者消息队列再保证一致性
>
> ​			3、延时双删（先删除缓存再更新数据库再sleep()再删除缓存）+分布式锁
>
> ​					如果mysqlDB实现了读写分离，那就是强制让对redis'的写入查询操作在主库中进行
>
> ​			4、消息队列
>
> 删除缓存失败的时候，发送一个消息体到消息队列里面，当系统收到消息队列的发送的消息再次对redis 进行删除操作
>
> ​	    	5、分布式锁





#### 6、memcache 和redis 用作缓存的区别

同 （1）都是存储K-V键值对，基于内存进行操作的，读写速度非常快

​     （2）都提供了内存过期策略

区别 ：（1）memcache只能储存简单的k-v键值对，但是redis中提供了多种数据结构，适应的场景更多

​			（2）redis提供了持久化机制

​			（3）redis 提供了多种集群方案

- 

### 三、redis 用作分布式锁

#### 1、redis 分布式锁可以解决哪些问题 ？

> 1、分布式集群下线程安全问题
>
> 2、缓存击穿
>
> 3、双写一致性

#### 2、为什么redis可以用作分布式锁？

> 当同时满足以下三个条件时，才可能引发线程安全问题：
>
> - 多线程环境
> - 有共享数据
> - 有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）
>
> 1、redis的主线程是单线程的，如果存在多个客户端同时获取锁的情况，只有一个客户端会成功获取锁，其他客户端会被阻塞，直到获取锁的客户端释放锁。
>
> 2、redis的很多操作都是原子性的，即在并发环境下也不会出现竞争条件。
>
> 3、Redis支持过期时间：Redis提供了键过期功能，可以为一个键设置过期时间，在该时间到达后，键会自动被删除。这个特性可以用来防止死锁和资源浪费
>
> 4、支持lua脚本，可以避免

#### 3、一个相对安全的分布式锁应该满足哪些条件？

互斥性、超时释放锁、可重入、高可用和高性能

#### 4、redis 如何实现分布式锁？（详情见”开发“）

使用setNX key value 和set  key value nx ex time  + lua脚本（保证操作的原子性）

- 一个时刻只有一个线程能够获取 ： setNx  lock 线程
- 不会造成**死锁**（那么redis宕机了锁也要能够释放）  ：给 lock 设置过期时间  expire key yime
- 上述 两条命令没法保证**原子性** ：set lock 线程 nx ex time 
- 业务没有执行完锁已经释放了
- 业务没有执行完锁已经释放了线程2获取锁此时线程1苏醒删除了线程2的锁： 释放锁之前判断一下锁是谁的
- 先判断再去删除这个操作不是原子性的 ： 使用Lua脚本

###### 1、存在的问题 ：

上述redis分布式锁依旧存在问题 ：不可重入、不可阻塞地获取锁、超时释放锁但业务未执行完、redis集群情况下主从不一致【在集群模式下，redis宕机之后主从之间不一致，会导致锁消失】

**（1）超时时将释放锁但业务未执行完**

- 方法一：

  让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。）

- 方法二：开源框架redission解决了这个问题。

  redission通过watch dog 机制实现锁续期。redission获取锁成功之后会维护一个watch dog，由watch dog定时对锁进行监听和处理。**一般来说在加锁的时候不设置过期时间，就会开启watch dog机制**。 默认的过期时间是30s，watchdog每10s检查一次，如果线程还没有持有锁并且还没有释放锁完就会将时间重新设置为30。

###### 2、watch dog 机制的原理

redission中一旦加锁成功，就会自动开启一个watch dog，**watch dog 是一个后台线程，定时对锁进行监听和处理**，watchdog每10s检查一次，如果线程还没有持有锁并且还没有释放锁完就会将时间重新设置为30。

**（2）不可重入**

-  将线程和锁进行绑定并且记录已经重入的次数就可以实现【这种方法存在的问题就是不能使用String类型，因为要记录重入的次数，如果要使用其他的数据结构就不能使用ex设置过期时间】

- 方法二：开源框架redission解决了这个问题。

  redission中通过使用Lua脚本实现了对锁的重入，redission会给锁生成一个计数器，用来记录锁可重入的次数。实现 hash 中的filed 是线程id ，value 是计数器

  

**（3）不可阻塞地获取锁**



**（4）主从不一致**

- 使用redis 的setNX key value 和set key value NX EX TIME 这两种方式实现的分布式锁，从高可用的角度来看是有所欠缺的。redis单机的情况下，如果redis发生故障，那么实现的redis锁就不可用。一般都会采用集群的方式实现高可用	。主要是 主从复制+哨兵模式。

- 正常情况下：如果加锁成功了，那么锁会被master节点异步复制给slave节点，如果在这个过程中master发生了故障（主要是master节点中 的锁还没复制给salve就进行了主备切换，此时新的master节点中还没有锁） 官方提供的解决方案是RedLock（备注：如果master节点宕机期间，可以容忍多个客户端同时持有锁，那么就不需要redLock）

#### 5、Redisson 的实现有哪些重点 【使用redission实现分布式锁】

##### 5.1 redission实现分布式锁原理 

redission是一个基于redis的分布式框架，它的加锁是基于redis的setNX命令实现的，它利用lua脚本保证了获取锁和释放锁的这两个操作的原子性，在获取锁时会先执行对应的lua脚本，它会先去判断锁是否已经存在，不存在的话就会将数据库写入redis数据库中，加锁成功。如果已经存在就会加锁失败，这里有一个while循环，会一直尝试获取锁。

如果是redis 集群的情况，它会先使用hash 计算出一个节点（现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。

http://t.csdn.cn/nrOEE



#### 6、setnx 为什么是原子性？

SETNX 是 Redis 中的一个原子性操作指令，它可以用于实现分布式锁等功能。SETNX 的原子性指的是多个客户端并发执行 SETNX 操作时，只有其中一个客户端能够成功地将键值对设置到 Redis 中。

**SETNX 命令的原子性是由 Redis 内部的单线程机制所保障的。**在 Redis 中，所有命令都会交给一个单独的线程执行，这个线程会依次执行命令队列中的每个命令，并根据自己的特性维护自己的状态。对于 SETNX 命令，Redis 的单线程机制会保证在执行该命令时，任何其他命令都无法干扰其执行结果。具体来说，当 SETNX 命令被执行时，Redis 会检查要设置的 key 是否已经存在，如果不存在，则会执行 SETNX 命令将 key 设置为指定的 value，此时 Redis 会阻塞其他客户端的读写请求，直到 SETNX 命令执行完成并返回结果。

因此，无论是单个客户端还是多个并发的客户端，SETNX 命令执行时都不会出现并发问题，即 SETNX 命令具有原子性。同时，Redis 还提供了诸如 INCR 和 DECR 等其他单个命令具有原子性的操作，在分布式场景中也可以利用这些指令实现原子性操作。



### **四、redis持久化**

redis 的持久化机制有3中

##### 1、讲一讲Redis持久化机制？

##### 2、如果我采取AOF持久化方式，并且想要高可靠性保证，选择哪一种写回策略，为什么？

##### 3、如果我想要数据不能丢失，如何让RDB和AOF混合使用来满足我的诉求

> 好的，了解 Redis 持久化吗？”
>
> **小龙**：“enen，是这样的，Redis 为了保证宕机能恢复数据，提供了持久化手段，可以采用RDB、AOF持久化，Redis4.x后更支持RDB、AOF混合持久化。”
>
> **面试官**：“那说说 AOF 持久机制是怎样的？”
>
> **小龙**：“简单来说，AOF 文件是将写操作命令按照约定的格式保存下来，若宕机顺序执行命令即可恢复数据；并且它采用 “**写后日志**”的模式，即 Redis 先执行命令写内存，后写日志；”
>
> **面试官**：“为何采用写后日志呢？”
>
> **小龙**：“嗯，首先 Redis 执行命令先写内存，这样可以对命令做预检，防止错误命令记录到日志；同时，记录AOF日志时，无须对语法做检查，因此写后日志还可以避免额外开销。”
>
> **小龙**：“并且，由于是命令执行完后再写日志，也不会阻塞主进程写操作。”
>
> **面试官**：“刚才你说 AOF 是一直追加命令，那随着时间推移，这个AOF文件不会越来越大吗，Redis是怎样处理的呢？”
>
> **小龙**：“Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制。”
>
> **独白**：“关于小龙面试经典分析全记录在[【面试笔记】](https://hd.nowcoder.com/link.html?target=https://mp.weixin.qq.com/s?__biz%3DMzkxMjE5NzUxNQ%3D%3D%26mid%3D2247486890%26idx%3D1%26sn%3D4815052ae4bf4d639f3aa7a1f727fa6a%26chksm%3Dc111df4ef6665658f3b9cb03a71c7a4b0b1660a634c4a0239898bd848de75add29a9e2324ac1%26token%3D2033911850%26lang%3Dzh_CN)中，有详细总结。”
>
> **面试官**：“这个重写机制是怎样的呢？”
>
> **小龙**：“简单来说就是，首先知道 AOF 里面存的写操作命令，但是很多条执行命令可能起到的效果最后只需要几条命令即可实现。”
>
> **小龙**：“重写即把冗余的命令用新的命令替换，再将新命令记录到新的 AOF 文件中，最后再替换老的 AOF 文件。”
>
> **面试官**：“那如果是大量写入，线程将会被长时间阻塞，Redis 是单线程的，这样就不能处理客户端的请求命令，怎么办？”
>
> **小龙**：“主进程是通过 fork 一个 bgrewriteaof 子进程进行 aof 日志重写。由于后台新开进程重写，主进程可以继续处理命令请求，可以避免阻塞主进程。”
>
> **小龙**：“但是fork子进程这个操作也是主进程实现，其中由于要复制父进程的页表等数据结构，若页表过大，便可能阻塞主线程。”
>
> **面试官**：“那假如你在写原来的数据时，父进程又处理了新的命令，会造成子父进程数据不一致吗？”
>
> **独白**：“这就有装逼得啦～”
>
> **小龙**：“子进程进行日志重写时，若有新数据写入，主进程执行完命令后会将命令写入到 「**AOF 缓冲区**」和 「**AOF 重写缓冲区**」”
>
> **小龙**：“然后，子进程重写完成后，会异步向主进程发送一条信号；”
>
> **小龙**：“主进程接收到信息，便将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，最后修改文件名，原子切换老文件，完成重写便保证了数据的一致性。”
>
> **面试官**：“那如何开启AOF的？”
>
> **小龙**：“可以手动触发，也可以文件配置。”
>
> **面试官**：“具体说说呢？”
>
> **小龙**：“可以通过配置 redis.conf 文件来开启 AOF 持久化 `appendonly yes`，同时需要联合配置同步策略，触发时机。但是 AOF 的重写需要 fork，这是一个重量级操作，可能会对 Redis 造成阻塞。”
>
> **小龙**：“因此为了不影响 Redis 主进程响应，我们需要尽可能降低 fork 的频率，降低阻塞，可以通过 bgrewriteaof 手动来触发 AOF 重写。”
>
> **面试官**：“Ok，我看你简历写了 MySQL，说说什么是 MySQL 两段提交吧？”
>
> **小龙**：“其实所谓的两阶段就是把一个事物分成两个阶段（prepare、commit）来提交，而实际上开启两阶段提交只是为了保证 redolog 和 binlog 日志数据的安全一致性。”
>
> **小龙**：“若你压根不需要使用 binlog 进行日志备份，主从复制相关的，其实完全可以不用两阶段提交，因为仅保证 redolog 成功写盘就可以保证 crash 的恢复啦。”
>
> **面试官**：“能讲一下具体怎样提交的吗？”
>
> **小龙**：“可以完整的分析一下，假如现在需要更新一条数据，前面肯定都知道会权限判断，词发语法分析，优化器生成最佳执行计划，准备执行，执行前还会记录 undolog 便于回滚，然后开始调用存储引擎执行 SQL。”
>
> **小龙**：“此时若选用 InnoDB 引擎，会看 buffer pool 里有无相关数据，没有会将数据先加载到 buffer pool 进行更新；”
>
> **独白**：“当然还涉及到唯一索引，普通索引等细节，这里不详细展开，具体可以看[【面试笔记】](https://hd.nowcoder.com/link.html?target=https://mp.weixin.qq.com/s?__biz%3DMzkxMjE5NzUxNQ%3D%3D%26mid%3D2247486890%26idx%3D1%26sn%3D4815052ae4bf4d639f3aa7a1f727fa6a%26chksm%3Dc111df4ef6665658f3b9cb03a71c7a4b0b1660a634c4a0239898bd848de75add29a9e2324ac1%26token%3D2033911850%26lang%3Dzh_CN)”
>
> **小龙**：“最后内存数据更新后，会将这个更新操作会记录到 redo log，redo log 处于 prepare 状态，告知执行器执行完，可提交事务。”
>
> **小龙**：“执行器生产这个操作的 binlog，并将 binlog 写入磁盘，执行器调用引擎事务提交接口，引擎把刚写入的 redo log 改为 commit 状态，最后更新完成；”
>
> **小龙**：“此刻整个过程完成，最后事务提交时便是分两个阶段提交。”
>
> **面试官**：“Ok，用过 explain 吗，explain 语句会执行 SQl 吗？”
>
> **小龙**：“explain 只走到优化器，要扫描多少行也只是个估计值，并没有实际执行。它只是一个执行计划，生成来自优化器关于 SQL 的执行信息，但是如果查询在 FROM 中子句包括子查询，MySQL 会执行子查询”
>
> **独白**：“不愧是我，真男人是也！[【面试笔记】](https://hd.nowcoder.com/link.html?target=https://mp.weixin.qq.com/s?__biz%3DMzkxMjE5NzUxNQ%3D%3D%26mid%3D2247486890%26idx%3D1%26sn%3D4815052ae4bf4d639f3aa7a1f727fa6a%26chksm%3Dc111df4ef6665658f3b9cb03a71c7a4b0b1660a634c4a0239898bd848de75add29a9e2324ac1%26token%3D2033911850%26lang%3Dzh_CN)在手，大厂 offer 不愁。”

### 五、redis 集群

redis 集群有三种类型，主从集群、哨兵模式、分片集群



##### 1、redis 主从同步

###### 1、说一下redis的主从同步

redis的主从同步是指将主节点上的数据同步到从节点上，从节点只负责更新自己的数据副本，不对数据进行写操作。

###### **主从同步的作用：**

> ​			实现数据备份、
>
> ​			可以避免单点redis发生故障导致不可用的情况（主备切换）
>
> ​			实现读写分离（写操作在master上进行，读操作从salve中进行）

###### 怎么配置主从集群

###### 2、主从同步策略

Redis的主从结构可以采用**一主多从**或者**级联结构**

**主从同步策略**有***全量同步***和**增量同步**

全量复制一般发生在slave 第一次发送请求的时候

增量复制一般发生在

###### 全量同步 ：

> 全量同步可以分为3个阶段，slave使用replicaof 主节点ip 主节点port 来配置主从关系，在第一个阶段里，执行replica ip port 命令此时会发送数据同步请求（psync）给master，每个redis节点都有replicaID和offset ，会跟着数据同步请求（psync）一起发送到master中，master会根据这两个参数来判断该slave是不是第一次发送数据同步请求，如果是的话就会把自己的replicaID和offset发送给salve，为之后的数据同步做准备。
>
> 在第二个阶段中 salve收到replicaid和offset 之后会存储起来，并且删除自己原有的数据，主线程会重新开一个子线程，执行bgsave生成一个rdb文件，异步发送给slave
>
> 在第三个阶段中，在生成rdb的过程中会有新的数据写入master，这些命令会被放入replication buffer中，会发给salve，salve执行这些命令
>
> ![image-20230515155820469](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230515155820469.png)
>
> ![image-20230515160048717](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230515160048717.png)

###### 增量复制：

增量复制发生在salve断开重启之后，

slave重启之后会给master发送psync命令，psync命令中有两个参数（replicaID 、offSet）

master接受到数据同步请求之后会来判断replicaID是不是和自己一样，一样的话就会执行增量同步策略，在master 中有一个repl_backlog_buffer（是环状的） 和replication offset 。repl_backlog_buffer 是一个环状的缓冲区，记录了master执行的写操作的命令，replication offset中master_repl_offset就记录了master写操作的位置 ,slave_repl_offset 就记录了slave发生故障之前读到的位置。

如果slave 断开连接的时间太久了，从节点要读取的数据已经不在repl_backlog_buffer中了就要进行一次全量同步。

###### 3、Redis主从节点同步时长连接还是短连接？

###### 4、怎么判断redis某个节点是否在正常工作？

###### 5、replication buffer 和rep_backlog_buffer 的区别

###### 6、redis主从复制是同步还是异步？

###### 7、**怎么搭建redis主从集群**

###### 8、redis集群下过期key如何处理

###### 9、redis集群下主从缓存中数据不一致

###### 数据不一致的原因

###### 如何尽最大可能保证数据的一致性

###### 10、redis 如何做到故障自切？

（slave 宕机重启之后可以根据主从复制恢复slave中的数据，master宕机怎么办？）

master宕机启动时可以根据持久化了的备份数据进行恢复，但是在这个恢复的过程不能进行读操作。

而且master宕机之后是不能自动进行主备切换的，需要哨兵自动完成故障转移和通知应用方

##### 2、redis 哨兵

###### 1、为什么要有哨兵机制？（哨兵机制的作用）

在分布式集群下进行读写分离，master 宕机了，此时读操作就不能再进行了。这个时候需要手动将一个slave节点设置为matser节点。

redis 就提供了哨兵机制，让哨兵来监控master，如果发生master宕机了就进行选主自动完成故障转移并且通知应用方（java客户端）。

###### 2、 哨兵如何工作？

哨兵主要做的事情有 监控、选主、通知

###### 3、如何判断master真的故障了？

如何判断节点是否正常？哨兵每隔1s就给所有的节点都发送一个ping命令，节点接受到ping命令之后就会响应一个pong。哨兵接收到pong就会认为该节点正常运行

主观下线： 哨兵给master发送ping，如果哨兵在规定时间内没有收到master发送过来的pong，那就主观认为maste故障，这就是主观下线。

客观下线：当一个哨兵判断master为主观下线之后，这个哨兵会给其他哨兵发送命令，其他哨兵接受到命令之后会根据自身情况和网络状况做赞成投票或者拒绝投票的响应。如果超出一半是赞成就认为该master节点是客观下线。

###### 4、由哪个哨兵成为leader来执行主从故障转移？

哪个哨兵发现了master故障就由哪个哨兵成为leader来执行故障转移，

该哨兵给其他的哨兵发送命令进行投票是否赞同自己成为leader（投票数要大于半数和哨兵配置文件中的quorum值）

###### 5、主从故障转移的过程是怎么样的？

（1）选出一个新的主节点

首先会排除那些网络状态不好的节点。

其次 会先根据slave_priority 小的节点。

在slave_priority 相同的情况下选择 slave_repl_offset 大的节点。

在slave_repl_offset相同的情况下选择id号小的节点。

leader哨兵会给该节点发送 slave no one 的命令，将这个节点设置为主节点

（2）将其他从节点指向新的主节点

leader哨兵会给其他从节点发送 slave of 主ip 主port 命令

（3）通知java客户端，master已经发生变化

这个是通过redis的发布者和订阅者机制来实现的。每个哨兵都会提供发布者和订阅者机制，客户端和哨兵建立起联系之后就可以订阅哨兵提供的频道。

（4）将旧的master节点设置为slave

给master 节点发送slave of 主ip 主端口的命令

##### 3、redis分片集群

###### 1、解决的问题 

 海量数据存储（主从同步的时候，为了提高redis的性能，redis的内存不能设置得太大（如果太大了的话在持久化和全量复制的时候会导致大量的io，），因此导致了在这种情况下海量数据的存储问题）

高并发情况下写的问题（主从复制，redis集群可以实现读写分离，解决高并发情况下读的问题）

数据的高可用

###### 2、redis集群的结构

redis集群中有多个master，每个master都存储不同的数据，每个master又有多个slave。此时不需要哨兵，master之间互相监控。客户端可以访问任意的master（客户端跟master中的一个连接就可，它会经过算法映射到正确的master节点中，这就需要用到slot映射算法）

###### 分片 :

将数据分片存储在不同的master中

###### 槽位：

16384个槽位

###### slot映射算法：

哈希取余、一致性哈希算法、哈希槽分区

**哈希槽分区算法：**总共有16384个slot槽位，平均分配给master。

如果此时redis cluster 要进行扩容，会把之前master拥有的槽位分配给之后的那个master

**redis cluster 的扩容和压缩**

###### 3、redis cluster 怎么实现高可用？

redis cluster 使用数据分片、主从复制、节点监控、故障转移等方法来实现高可用。

> 数据分片：Redis Cluster将数据分片存储在多个节点中，每个节点只存储部分数据。这样，即使某个节点出现故障，其他节点仍然可以提供服务，不会影响整个集群的可用性。
>
> 节点复制：Redis Cluster使用主从复制机制来保证节点的高可用性。每个节点都有一个或多个从节点作为备份，当主节点出现故障时，从节点会自动接管主节点的工作，保证服务的持续性。
>
> 节点监控：Redis Cluster通过对节点的监控来及时检测故障，并自动将失效的节点从集群中移除，以避免出现数据丢失或延迟。同时，Redis Cluster还会自动将新节点加入到集群中，以提高整个集群的可用性。
>
> 故障转移：当主节点出现故障时，Redis Cluster会自动进行故障转移，将主节点的工作转移到一个从节点上，并将该从节点升级为主节点。这样，即使某个节点出现故障，整个集群仍然可以提供服务，不会影响业务的正常运行。

redis 怎么实现高可用性？

> 1. 主从复制：Redis支持主从复制，即一个Redis主节点将自己的数据同步到多个Redis从节点上，从而实现数据备份和故障恢复。当主节点出现故障时，Redis可以自动将其中一个从节点升级为新的主节点，从而保证服务的可用性。
> 2. Sentinel： 它通过监控Redis节点的状态和执行自动故障转移来实现高可用性。Sentinel可以检测Redis节点的状态，并在发现故障时，自动将其中一个从节点升级为新的主节点，并重新配置其他从节点的连接信息，从而实现故障转移和高可用性。
> 3. Cluster： 它通过数据分片和主从复制来实现高可用性。Redis Cluster将数据分散到多个Redis节点上，每个节点都有一个或多个从节点作为备份。当节点出现故障时，Redis Cluster可以自动将其中一个从节点升级为新的主节点，从而保证服务的可用性。

###### 4、如果 Redis 集群中的一台节点突然挂了，并且该节点上有未处理的请求，这个请求怎么办呢？



###### 5、在 Redis 集群环境下，Redis 内存中的数据一致性如何保证？

在redis cluster 环境下，redis中的数据是没有办法保证强一致性的



> 1. 数据分片：Redis Cluster使用数据分片来将数据分散到多个节点上，每个节点都只保存部分数据。当一个客户端请求某个数据时，Redis Cluster会自动将该请求路由到正确的节点上，从而保证每个节点只保存自己所负责的部分数据。通过数据分片，Redis Cluster可以避免单节点负载过高的问题，并且可以提高系统的可扩展性和性能。
> 2. 主从复制：Redis支持主从复制，即一个Redis主节点将自己的数据同步到多个Redis从节点上，从而实现数据备份和故障恢复。当主节点发生故障时，Redis可以自动将其中一个从节点升级为新的主节点，从而保证服务的可用性。主从复制可以保证数据的备份和恢复，同时也可以提高系统的可靠性和可用性。

###### 6、Redis集群 怎么样做动态插入又不影响hash槽均匀分配

###### 7、redis的集群，如何解决均匀分布数据（1-10台节点，有一台坏掉了），这台主机的数据如何恢复？

##### 4、Redis 服务宕机：

> （1）搭建高可用 Redis 集群；
>
> （2）利用熔断机制，**暂停业务应用对缓存服务的访问，直接返回错误**，不用再继续访问数据库。
>
> （3）限流机制：**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

###### 1、什么是熔断？

当系统中某一个服务出现性能瓶颈时，对这个服务的调用进行**快速失败**，避免造成连锁反应，从而影响整个链路的调用。

服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。

###### 2、熔断和限流的区别？

限流是指上游服务对本服务请求 QPS 超过阈值时，通过一定的策略(如延迟处理、拒绝处理)对上游服务的请求量进行限制，以保证本服务不被压垮，从而持续提供稳定服务。常见的限流算法有滑动窗口、令牌桶、漏桶等。

### 六、redis数据结构  

#### SDS			

#### ZipList		

#### QuickList

#### SkipList

跳表本质是一个双链表，每个节点存储的是(data,score)，节点按照score升序排列，每个节点有多个指针。

##### 1、知道为什么Redis zset要用跳表而不是红黑树吗？

相比于红黑树

（1）实现	 ：跳表的实现更加简单

（2）增删     ：跳表增删的实现更简单，再增删的时候只需要维护该节点前后两个节点的，修改一下指针的指向，但是红黑树要进行旋转这一系列的操作

<!--1、跳表的实现更加简单，不用旋转节点，相对效率更高
2、跳表在范围查询的时候的效率是高于红黑树的，因为跳表是从山层往下层查找的，上层的区域范围更广，可以快速定位到查询的范围
3、平衡树的插入和删除操作可能引发子树的调整、逻辑复杂，而跳表只需要维护相邻节点即可
4、查找单个key，跳表和平衡树时间复杂度都是O(logN)
-->

（4）内存占用  ：跳表的占用的内存更少，跳表只需要使用层级指针来构建跳跃结构，而红黑树要记录指针还需要记录节点的颜色和额外的指针







### 七、redis数据类型



#### 1、string

##### 1、Redis String类型的底层是如何实现？

**编码方式** ：  int 、raw、embstr

**redis string 类型底层数据结构的实现** ：SDS

> ![image-20230516141939434](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230516141939434.png)
>
> SDS   :   结构体可以分为 len、alloc、 flag、buff[ ]
>
> len    :   存储的是 buff中字符串的长度
>
> alloc ：用于申请内存空间，记录申请的内存空间的大小
>
> flag   ： SDS的类型，
>
> buff[]:    里面存放数据（比如name）

##### 2、为什么Redis要用简单动态字符串 SDS？

> (1) SDS不以特殊字符作为结束的标志，因此它不仅可以存储文本数据，更可以存储音频、图片这样的二进制数据，它是二进制安全的。
>
> (2)SDS结构体中有一个名为len的属性，它记录了字符串的长度，因此获取字符串长度的时间复杂度为o(1)
>
> (3)SDS支持动态扩容，拼接字符串的时候sds会先判断内存是否足够，不够的话会先扩容
>
> ![image-20230516142440475](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230516142440475.png)



##### 3、String 类型的应用场景

> (1) 用作分布式锁
>
> (2) 缓存session信息

#### 2、list

##### 1、Redis list类型的底层是如何实现？

**Redis list 类型底层数据结构的实现 ：**

> 3.2 之前   压缩链表 （ZipList）    ： 当存储的数据小于512，并且每个数据字节数小于64时 
>
> ​			 	双端链表（linkedList）： 不满足上面那个条件
>
> 3.2 之后： quickList （quickList 的底层是ZipList+LinkedList ）

##### 2、Redis list 类型的应用场景

> 消息队列

##### 3、ziplist怎样实现的 		



##### 		

 1、知道为什么Redis zset要用跳表而不是红黑树吗？

redis是一个单线程的服务，它更加追求查询速度，redis本身是基于内存的，所以它的性能瓶颈在于内存和网络带宽

2、Redis是单线程的吗？

 

5、Redis Sorted set类型的底层是如何实现？



7、Redis字典底层怎么实现的

 



### 八、 redis相关项目问题

  1、 你怎么考虑秒杀优化的呢？
  2、<u>超卖问题怎么解决的？</u>
  3、用redis 能解决超卖问题吗？
 4、如果罗永浩有100个秒杀商品，全国人民来秒杀怎么redis能接的住吗？
 5、 redis集群能保证数据的一致性吗？有延时
 6、有一种方案看看可行不：还有有多台redis，但是只有一台有库存，看运气负载均衡到哪台
 7、如果12：01一个用户A秒杀请求负载均衡到没有库存的机器，但是12：02分另一个用户B运气好负载正确且秒杀成功？那岂不是说不公平，后台操作了？这怎么解决呢？
 8、有库存却秒杀不成功的情况？怎么解决？

13、高并发主要要考虑哪些问题？ 
 14、 如果集群的Redis中一台突然挂了，此时有请求未处理怎么办

> 当Redis集群中一台机器挂了，可以通过Redis Sentinel或Redis Cluster等机制来实现高可用性和容错机制。

 15、Redis如何设置均衡负载的？

在Redis集群中，负载均衡的目的是将客户端的请求分配到多个节点上，以实现分布式存储和高可用性。

 Redis可以通过一致性哈希算法、哈希槽等方式来实现负载均衡。

16、什么是热点Key问题？什么样的key被称为热key？如何解决热点Key？

17、redis主机向从机同步数据时，从机提供读服务吗？主机向从机同步数据需要时间，这个期间的一致性怎么保证？（不确定）

> CAP理论认为，在分布式系统设计中，由于网络通信的延迟和故障的不可避免性，无法同时保证一致性、可用性和分区容忍性这三个特性。在面对分区故障时，系统设计者必须在一致性和可用性之间做出权衡选择。
>
> 具体来说，当出现分区故障时，系统可以选择保证一致性和分区容忍性，但可能会牺牲一部分可用性；或者选择保证可用性和分区容忍性，但可能会牺牲一部分一致性。CAP理论指出，在分布式系统设计中，无法同时满足三个特性，需要根据实际需求和业务场景进行权衡和取舍。

##### 18、 redis 瓶颈

> redis 瓶颈 ： 内存容量限制、网络带宽（持久化、全量复制、大量读写请求的时候）
>
> 一些解决方法： 内存优化，数据分片，构建redis集群
>
> Redis的瓶颈主要取决于具体的使用场景和配置。以下是一些常见的Redis瓶颈因素：
>
> 1. 内存容量限制：Redis是内存数据库，它的性能和容量受限于服务器的内存大小。当数据集的大小超过可用内存时，Redis可能会出现内存不足的情况。
> 2. 网络带宽：如果Redis在分布式环境中使用，网络带宽可能成为瓶颈。特别是当大量的读写请求和复制同步数据在节点之间传输时，网络带宽的限制可能会影响Redis的性能和响应时间。
> 3. CPU资源限制：Redis的性能也受限于服务器的CPU性能。当Redis需要处理大量的并发请求、进行复杂的计算或执行持久化操作时，CPU资源可能成为瓶颈。
> 4. 持久化操作：如果Redis配置了持久化功能（如RDB快照或AOF日志），持久化操作的频率和数据量可能会对Redis的性能产生影响。频繁的持久化操作可能导致阻塞和延迟。
> 5. 键访问热度：当部分键的访问频率非常高时，这些热点键可能会成为Redis的瓶颈。如果大部分请求都集中在少数热点键上，可能会导致负载不均衡和性能下降。
> 6. 单线程模型：Redis默认采用单线程模型，即所有请求都在一个线程中顺序执行。尽管单线程模型简化了并发控制，但在极高并发负载下，单线程可能成为性能瓶颈。
>
> 以上只是一些常见的Redis瓶颈因素，实际情况会因应用程序的特点和部署环境的不同而有所差异。为了解决潜在的瓶颈问题，可以通过增加服务器资源（如内存、CPU、网络带宽）、优化配置、使用集群部署、合理设计数据模型和使用缓存策略等手段来提升Redis的性能和扩展能力。

 \6. Redis用来做消息队列的出发点是什么？跟其他的消息队列比有什么缺陷？
\7. Redis用了哪些数据结构？【大坑的问题】
\8. 线上应用是多机房部署的情况下，设计缓存服务的时候，会考虑哪些点？
\9. 回答了主备，继续问：主备集群能适合机房容灾嘛。考虑到容灾的特点，怎么构建缓存服务
\10. 回答了缓存雪崩、击穿，继续问：怎么设计来满足可用性
\11. 使用redis集群，考虑业务规模和提效，怎么部署/设计哪种部署架构，会比较适合业务的发展。
\12. 回答了节点插拔，继续问：节点插拔是什么模式、redis集群的特点是什么（回答了哈希槽）
\13. redis集群相比于单机版的会有什么使用上的问题？



### 八、 基于redis的消息队列

1、消息队列的作用（解决了什么问题）

2、作为消息队列应该满足哪些要求

3、基于redis 实现的消息队列有哪些？

1、用list来实现消息队列：

2、使用pubsub（发布者-订阅者）实现消息队列：

3、使用stream来实现消息队列

## 1.1内存回收策略

redis之所以强，是因为它基于内存。但是单个节点的redis的内存不易过大，否则会影响性能（持久化、主从复制）。因此需要进行内存回收

**内存回收策略**： 过期策略和淘汰策略

### 1.1.1过期策略 

问题 ：***redis怎么知道键过期了？***

​		redisDB中有两个字典，一个存储键值和对应的value值，另外一个存储键值和对应的过期时间。

​			***键过期了什么时候清除呢？***

​		惰性删除和定期间删除和定时删除

![image-20230514152537290](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514152537290.png)



### 1.1.2 内存淘汰策略

***什么是内存淘汰？***

***什么时间检查内存是否达到了阈值？***

***内存淘汰策略有哪些？（8种）***

> 不淘汰key（默认）
>
> 
>
> 删除ttl较小的key
>
> 在所有的key中随机抽取
>
> 在设置了过期时间的key中抽取
>
> ![image-20230514153945101](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514153945101.png)
>
> 在所有的key中按照LRU策略淘汰key
>
> 在设置了过期时间的key按照LRU策略淘汰key
>
> 在所有的key中按照LFU策略淘汰key
>
> 在设置了过期时间的key中按照LFU策略淘汰key
>
> ​			LFU：最少频率使用

 ![image-20230514163636023](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514163636023.png)








##### 什么是redis

​	一个基于内存的存储k—v 键值对的NoSQL数据库

​	有多种数据类型 ：String 、List 、set 、Zset、hash

##### 

##### redis数据结构

## 你说你了解Redis，讲一下

Redis有五种基本数据类型，String、list、set、hash和sorted_set。String底层是用int或者字符串来实现的。list底层在3.2之前使用ziplist或者linkedlist来实现的，3.2之后用的是quicklist来实现的。set底层是用intset或者字典来实现的。hash底层是用ziplist或者字典来实现的。sorted_set底层是用ziplist或者字典+跳表来实现的。

> 动态字符串、intset、Dict、ZipList、QuickList、SkipList、RedisObject
>
> redis中的key 是字符串，value是字符串/ 字符串的集合

###### **SDS （动态字符串）： **

> 保存单个字符型
>
> 性能 ： 获取字符的长度的时间复杂度为o(1)
>
> 支持动态扩容
>
> 二进制安全（redis 是使用C语言写的，C语言是根据"/0"来判断字符的结尾）

![image-20230514122559697](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514122559697.png)



![image-20230514122742793](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514122742793.png)



###### intset

> 特点：可以看成是int型的数组，在内存上连续，适合少量数据存储
>
> redis会确保inset中的元素唯一有序
>
> 具有类型升级机制（存储数据不够时会自动升级）
>
> 底层采用二分法来查询

###### Dict

> Dict 由三部分组成，哈希表、哈希节点、字典
>
> ![image-20230514140016962](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514140016962.png)
>
> ![image-20230514140057525](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514140057525.png)

> Dict的扩容
>
>  
>
> ![image-20230514140355511](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230514140355511.png)

###### ZipList

##### 五种基本数据类型:

> String   :                        
>
> **使用场景 :**
>
> ​	存储常规数据（字符串）序列化（图片）的数据，将redis作为缓存
>
> 
>
> List：
>
> **底层实现** ：（双端链表） quickList +（跳表）zipList
>
> **使用场景：**消息队列
>
> 
>
> set：
>
> 底层实现：
>
> 使用场景： 点赞、收藏
>
> 
>
> Zset：
>
> 
>
> hash：
>
> 
>
> 
>
> ##### 对应的底层结构:
>
> 
>
> ##### 使用的场景:







##### redis的三种集群方式

​		主从

​		哨兵

​		集群

集群的redis中有一台突然挂掉了，此时有请求未处理怎么办？

如何设置负载均衡？

使用redis实现分布式锁

redis怎么防止刷单？

redis怎么保证数据一致性？

缓存穿透缓存雪崩缓存击穿  以及解决的策略





核心功能：

​	cache ：

​	store

数据的特点 ：

> 数据存储在内存中
>
> 读写速度快-------------------------> 适用于高并发
>
> 断电即消失---------------------------> 持久化（将数据写到磁盘）

## **2、redis中的持久化机制**

##### **持久化机制 ：** 

快照 和AOF

##### **缓存清空策略**：

缓存的存储空间有限制，当缓存空间被用满时，就需要缓存清空策略来处理，常见的一般策略有：

    先进先出策略：先进入缓存的数据，在缓存空间不足时会被优先被清理掉，在数据实效性要求较高的场景下，可选择该策略
    
    最少使用策略：无论是否过期，根据元素被使用的次数判断，清除使用次数较少的元素。最少使用策略主要比较元素的命中次数，在保证高频数据有效性场景下，可选择该策略
    
    最近最少使用策略：无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素。策略算法主要比较元素最近一次被使用的时间，适用于热点数据场景

————————————————

原文链接：https://blog.csdn.net/CSDN_handsome/article/details/108738031



## 3、redis的使用场景

**（1）时效性** 存储验证码、存储token、具有时效性的业务功能

（2）分布式集群系统中存储session ，实现session共享

memcache（数据类型单一、数据存储有限）

（3）利用zset做排行榜功能

（4）分布式缓存

（5） 解决**分布式集群系统中**的分布式锁问题（高并发情况超卖问题）

分布式集群系统中有多台服务器



## 4、 缓存

缓存是什么 ？

**作用 ：**

提高读写效率，降低响应时间，减轻数据库的压力

**成本 ：**

为了数据一致性（代码维护）

**将redis作为缓存实现步骤** ：

当读请求到达之后，先去redis中查找，找不到再去数据库中查找 （自己写代码实现）



### **4.1缓存更新策略**  （写操作）

内存淘汰机制： 开启即自动更新

超时剔除 ： 存入的时候设置淘汰时间

主动更新：在编写业务逻辑，修改数据库的同时主动更新redis

**---1----如何选择 ？**  

> ​		一致性要求低 ： 内存淘汰
>
> ​		一致性要求高： 主动更新 + 超时剔除

**----2----主动更新策略**

> （1）更新数据库的同时更新缓存（常用）
>
> （2）
>
> （3）

**-----3----更新数据库的时候同时更新缓存需要考虑的问题**

> （1）是更新缓存还是删除缓存？  删除缓存，再次读取这条数据时，再将该条数据写入缓存
>
> ![image-20230513202853569](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513202853569.png)
>
> （2）要保证更新redis 和 数据库的操作 同时成功/失败
>
> 单体项目：缓存和数据库操作放在一个事务中
>
> 分布式项目：
>
> 
>
> （3）先更新数据库还是先更新redis ？（**线程安全**）
>
> 先更新数据库，再删除缓存 



![image-20230513195211719](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513195211719.png)





### 4.2分布式缓存的实现

##### 4.2.1什么是分布式缓存：

![image-20230513135942751](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513135942751.png)

##### **4.2.2本地缓存存在的问题 **

 本地缓存存在服务器中（jvm），服务器关闭数据则消失

##### **4.2.3如何使用redis做分布式缓存**

> 可以利用 Mybatis 自带的本地缓存（map），结合 Redis 实现分布式缓存，主要思路是将 Mybatis 二级缓存的存放地**点从本地改为配置了 Redis 的远程服务器**
>
> ![image-20230513152806876](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513152806876.png)

#####  4.2.4处理表连接查询时的问题

![image-20230513140254681](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513140254681.png)

##### 4.2.5redis 缓存存在的问题：

###### **key 值过长 （大key）**

 MD5加密



###### 缓存穿透

> 请求的key值不在redis中就会去访问数据库中，然后请求的key也不在数据库中
>
> **key值不在redis中也不在数据库中**
>
> 解决方法： 使用布隆过滤器（byte数组，存储二进制位）
>
> ​					缓存空对象（使用ttl）  ----缓解

![image-20230513203649182](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513203649182.png)

###### **缓存击穿**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

> 热key值过期，大量的请求直接到达redis
>
> 解决方法 ：**加互斥锁（分布式锁）**，请求数据库时将加锁，只有一个请求能够抢到锁，其他请求等待

![image-20230513204540892](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513204540892.png)

![image-20230513204837541](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513204837541.png)

![image-20230513204936386](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513204936386.png)

###### 缓存雪崩

> 缓存雪崩 ： redis中大量的key值同一时间失效或者redis宕机，导致大量的请求到达数据库
>
> 解决方案：设定不同的失效时间、存储在不同的redis 节点中（提高redis集群的高可用性）、不失效、定时刷新

![image-20230513204144990](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513204144990.png)

###### 数据库一致性问题

## 5、主从复制

主 ：写

从：读

为什么需要主从复制 ：

（1）单台redis虽然读写速度快，但是单节点redis能够支撑的qps是50w，如果上千万的用户访问，redis就承载不了，称为高并发的瓶颈.

（2）单节点redis不能够保证高可用，redis宕机的话数据不可用

主从复制的作用 ：

> 数据备份
>
> 读写分离
>
> 故障转移 （+哨兵）

原理

![image-20230513160203856](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230513160203856.png)






