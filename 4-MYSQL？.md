# 【数据库】

## 1、 什么是关系型数据库？

## 关系型数据库和非关系系数据库的异同、各自有什么优缺点？

## mysql 存储引擎框架



InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。

MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。

MyISAM 不支持外键，而 InnoDB 支持。

MyISAM 不支持 MVCC，而 InnoDB 支持。

虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。

InnoDB 的性能比 MyISAM 更强大。

# 索引 

## 1、什么是索引？ 为什么要建立索引 ？ 索引的优缺点

**索引是一种用于*<u>快速查询</u>*  和 <u>*检索数据*</u> 的数据结构，其本质可以看成是一种排序好的数据结构。**


**索引的目的在于提高数据查询效率**。（减少磁盘I/O的次数，加快查询速率），帮助mysql高效获取数据
索引的出现，就是为了提高数据查询的效率，就像书的目录一样。
对于数据库的表而言，索引其实就是它的“目录”。

**索引是在存储引擎中实现的**

> 比如现在mysql 默认的存储引擎是Inndb，mysql中的索引是由Innodb 创建的，
>
> 底层使用到的数据结构是B+树 【叶子节点存储了真实数据、叶子节点之间是双链表 ，叶子节点中的数据记录之间是单链表，非叶子节点是没有存储真实数据存储的是页目录】

**优点** ：提高数据库检索的效率、降低数据库IO成本



**缺点** ：

- 创建索引和维护索引要耗费时间

   - 索引也需要占用磁盘空间  
   - 提高了查询效率的同时，降低了更新（增删改）表的速度

![image-20231007140405974](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20231007140405974.png)

## 2、mysql中索引的类型？

按照**数据结构**分类：b+ tree 索引、hash索引 （B+tree 索引、Hash索引、R-tree索引、Full-text）

按照**物理储存**分类：聚簇索引、二级索引

按照**字段特性**分类：主键索引、普通索引、唯一索引

按照**字段个数**分类：联合索引



### *2.1既然哈希表这么快，**为什么 MySQL 没有使用其作为索引的数据结构呢？** 

![image-20231007142303816](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20231007142303816.png)

### *2.2为什么不用二叉树、AVL 树？

**二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。**



由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。

并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。

 **磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。**

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/database/mysql/mysql-index.html

### 2.3 为什么不用红黑树

红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，**这也是 MySQL 没有选择红黑树的主要原因**。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作

每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/database/mysql/mysql-index.html



### 2.4B 树和B+树的区别

- B 树的所有节点既存放索引 也存放数据(data)，而 B+树只有叶子节点存放索引 和 data，其他内节点只存放 索引。
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。

综上，B+树与 B 树相比，**具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。**

------

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/database/mysql/mysql-index.html



#### 什么时候适用索引？

- 字段有唯一性限制的，比如商品编码；
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。



####  什么时候不需要创建索引？

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## [3、](https://www.xiaolincoding.com/mysql/index/index_interview.html#有什么优化索引的方法) 有什么优化索引的方法？

- 前缀索引优化
- 覆盖索引优化
- 主键最好是自增的
- 索引最好是not null 
- 避免索引失效

## 4、索引失效有哪些情况？

- 当我们使用**左或者左右模糊匹配的时候**，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效；

  【

  如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。

  

  但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树】

- 当我们在查询条件中**对索引列使用函数**，就会导致索引失效。

- 当我们在查询条件中**对索引列进行表达式计算**，也是无法走索引的。

- **MySQL  在遇到字符串和数字比较的时候，会自动把字符串转为数字**，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。

- **联合索引要能正确使用需要遵循最左匹配原则**，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。

- 在 WHERE 子句中，**如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列**，那么索引会失效。

  #### 

## 5、最左匹配原则是什么

在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

如果出现 部分索引

#### 最左匹配原则失效的场景

**联合索引的最左匹配原则，最左优先，以最左边的为起点任何连续的索引都能匹配上。 在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。注意，对于  >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。**



## 6、*索引下推

**索引下推（Index condition pushdown）** 简称 ICP，在 Mysql 5.6 版本上推出的一项用于优化查询的技术。

**在不使用索引下推的情况下**，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器判断数据是否符合条件。

而有了索引下推之后，如果存在某些被索引列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。

**索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。**

作者：程序猿周周
链接：https://www.nowcoder.com/discuss/353159394118541312
来源：牛客网

## 7、如果是大段的文本内容，如何创建(优化)索引？

1.分表存储，创建索引

2.使用es为大文本创建索引

## 8、为什么要回表查询？直接存储数据不可以么？



## 9.为什么以like=%开头会导致索引失效？

以%开头并不一定会导致索引失效

**结论：**在覆盖索引的时候，会走索引，type会等于index

类似复合索引未用左列字段失效一样，跳过开始部分也就无法使用生成的b+树了

## 10.如果表中有字段为null,又被经常查询该不该给这个字段创建索引？

创建。null其实也是数值，在查询如果为空，那么在B+树上，也都是空值

## 11.有字段为null索引是否会失效？



# 事务

## 1、什么是数据库的事务？

数据库的**事务**是一个**不可分割的数据库操作序列**，是逻辑上的一组操作，要么都执行，要么都不执行。其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。

## 2、什么是事务的四大特性（ACID）？

**原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，**不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态**，就像这个事务从来没有执行过一样

**一致性（Consistency）**：**是指事务操作前和操作后**，数据满足完整性约束，**数据库保持一致性状态。**比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A  的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有  800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600  元，总共 1200 元）。

**隔离性（Isolation）**：**数据库允许多个并发事务同时对其数据进行读写和修改**，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。

**持久性（Durability）**：**事务处理结束后，对数据的修改就是永久的，**即便系统故障也不会丢失。

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

## 3、并行事务(并发)会引发什么问题？

MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。

那么**在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）、脏写的问题**。

接下来，通过举例子给大家说明，这些问题是如何发生的。

### 3.1 什么是脏读？

**如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。**

### 3.2 什么是不可重复读？

**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。**

### 3.3 什么是幻读？

**在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。**



### 3.4 什么是快照读？

普通的select 语句就是快照读。

### 3.5 什么是当前读？

 `select ..... lock in share mode ,select ...... for update, update,insert,delect`

读取的是最新版本的数据。

## 4、事务的隔离级别的作用 ？事务的隔离级别有哪些？

前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，**这些现象会对事务的一致性产生不同程序的影响。**

**<u>SQL 标准提出了四种隔离级别来规避这些现象</u>**，隔离级别越高，性能效率就越低，这四个隔离级别如下：

> **【脏读、不可重复读、幻读】这三个问题需要数据库提供一定的事务隔离机制来解决，也就是事务的隔离性**

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

### 4.1 这四种隔离级别具体是如何实现的呢？

- **读未提交**

  > 因为可以读未提交事务修改的数据，所以直接读取最新的数据就行

- **读已提交 **和**可重复读**

  > **它们是通过ReadView来实现  **
  >
  > **「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View**
  >
  > **而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。**

- **串行化** 

  > 通过**加读写锁**的方式来避免并行访问

### 4.2 可重复读是如何工作的？

> **可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**。

怎么实现可重复读？

普通 select 语句 ：（快照读） MVCC 

当前读 ： 锁 

### 4.3 MySQL 有哪些事务隔离等级？应用场景分别是什么？高并发写场景能用 RR 吗？

 

## 5、MVCC

### 5.1 什么是mvcc？

多版本并发控制，MVCC 是一种并发控制机制，通过保存数据的多个版本来实现数据库的并发控制，**用于在多个并发事务【同时读写数据库时】保持数据的【一致性和隔离性】。**并且在 `Repeatable Read` 下 `MVCC` 实现了可重复读和防止部分幻读。



### 5.2 mvcc 的原理

> mvcc 的实现依赖于**记录中的隐藏字段 + undo log 链 + readView** 
>
> 在内部实现中，`InnoDB` 通过**记录中的隐藏字段** `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过**记录中的隐藏字段**的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。

[`Read View`](https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298) 主要是用来做可见性判断log是 `MVCC` ，

**undo-log的作用：**当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现非锁定读





# 幻读问题

## **怎么会造成幻读 ？**

> 读的时候有改增删操作

可串行化这个隔离级别才能彻底解决幻读这个问题

但是可串行化会对数据库的性能带来很大的影响（**降低数据库并发的能力**），因此一般不会选用可串行化 。

一般选用的隔离级别是 可重复读隔离级别。

但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：

快照读 （普通的select语句）：

> 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**

当前读（）

> 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

## **快照读是如何避免幻读的？**

> 可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，**后续的查询语句利用这个 Read View，通过这个  Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的**，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。

## **当前读是如何避免幻读的？**

> **Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁**。

**MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？**

在 MySQL 的可重复读隔离级别下，针对当前读的语句会对**索引**加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。

# Mysql 锁

## 1、MySQL中锁用来干嘛？

当数据库有并发事务的时候，可能会产生数据不一致问题，这时候需要一些机制来保证访问的次序实现事务的一致性和隔离性，锁机制就是这样的一个机制。**即锁的作用是解决并发问题**,。（解决写写冲突、读写冲突,**维护事务的隔离性：**）



## 2、mysql 有哪些锁？

**从使用性质划分**：可以分为共享锁、排它锁

**从锁的粒度划分**：可以将锁分为全局锁、表锁、行锁

> 
>
> ## 1、全局锁
>
> 对整个数据库加锁（`flush tables with read lock`），加锁后数据库处于**只读**状态，这时其他线程执行（1 对数据库的修改操作、2 对表结构的更改操作 都会被阻塞
>
> 全局锁主要 应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
>
> 那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。
>
> 如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个  Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
>
> ## 2、表级锁
>
> - 表锁 
>   - 对整张表加锁、表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
>
> - 元数据锁
>
>   - **MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。**
>
>   - **不需要显示地使用MDL ,因为当我们对数据库进行操作时，会自动给这个表加上MDL,MDL是在事务提交后才会释放的，这意味着事务执行期间，MDL是一直持有的。**
>   - 如果当前事务已经使用了MDL读锁，并且另一个线程申请MDL 写锁，此时就会被阻塞【 这是因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。
>
> -  意向锁
>
>   - 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
>   - 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
>
> 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
>
> 而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。
>
> 不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：
>
> ```sql
> //先在表上加上意向共享锁，然后对读取的记录加共享锁
> select ... lock in share mode;
> 
> //先表上加上意向独占锁，然后对读取的记录加独占锁
> select ... for update;
> ```
>
> 
>
> **意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（\*lock tables ... read\*）和独占表锁（\*lock tables ... write\*）发生冲突。**
>
> **意向锁的目的是为了快速判断表里是否有记录被加锁**。
>
> ## [3、行级锁#](https://xiaolincoding.com/mysql/lock/mysql_lock.html#auto-inc-锁)  
>
> 行级锁的类型主要有三类：
>
> - Record Lock，记录锁，也就是仅仅把一条记录锁上；
> - Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
> - Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

 `插入意向锁（Insert Intention）`，插入意向锁类似于 Gap Lock，不过插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。插入意向锁的主要目的是，如果别的事务在这个间隙加了 Gap Lock，那么要在这个间隙插入数据的这个事务就要生成一个插入意向锁的结构，然后等待。所以插入意向锁和 Gap Lock 是不兼容的。

## 3、Mysql是怎么加锁的？

（实则问题是问 ： innodb是怎么加锁的）

- 全局锁怎么加？
- 表级锁怎么加？
- 行级锁怎么加？

### 3.1 行级锁怎么加 ？

（1）前提 ：innoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎 的。

- 查询 

  - 普通查询

  普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过  MVCC（多版本并发控制）实现的。

  - 非普通查询语句

  ```sql
  //对读取的记录加共享锁(S型锁)
  select ... lock in share mode;
  
  //对读取的记录加独占锁(X型锁)
  select ... for update;
  ```

- 删、改

  > **update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。

- 增

  插入操作 ：如果存在间隙锁，那么就会先生成一个插入意向锁 ，自己处于等到状态

(2)  行级锁的类别有多种 

> 记录锁 ：
>
> - 锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：
>
> 间隙锁 ：
>
> - Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
>
> - **间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。
>
> 临建锁
>
> - **next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。
>
> 插入意向锁
>
> - **一个事务在执行插入操作的时候，会先检查插入记录的吓一条记录是否有间隙锁，如果有的话，该线程的插入操作处于阻塞状态，在此期间会生成一个插入意向锁，并且该锁处于等待状态，直到间隙锁被释放（*MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁***）

(3) 加锁的原则

**加锁的对象是索引，加锁的基本单位是 next-key lock**，**在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock  就会退化成记录锁或间隙锁**。

**如果锁定读查询语句**（update、delete、select ... for update 等具有加锁性质的语句**，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞**。



### 3.2  普通select 怎么加锁？ 

快照读 不需要加锁



### 3.3 当前读怎么加锁？ 



### 3.4 update 和delete 怎么加锁？



### 3.5 insert 如何加锁？



Insert 语句在正常执行时是不会生成锁结构的，**它是靠聚簇索引记录自带的 trx_id 隐藏列来作为隐式锁来保护记录的 。**

隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景

- 如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；
- 如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；

 每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（*PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁*），现象就是 Insert 语句会被阻塞。

## 4、**为什么会发生死锁，以及怎么避免死锁**。

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：

- **设置事务等待锁的超时时间**。
- **开启主动死锁检测**。

## 3、隔离级别和锁的关系？

1）在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；

2）在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

3）在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；

4）在 SERIALIZABLE 级别下，限制性最强，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

# 日志

## undo log

undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚

undo log 两大作用：

- **实现事务回滚，保障事务的原子性**。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。
- **实现 MVCC（多版本并发控制）关键因素之一**。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通  select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。

# Mysql 主从同步





# Mysql持久化



# Mysql查询

MySQL 慢查询有用过嘛？给你一个SQL语句，你怎么去优化【我从索引开始入手回答、索引失效问题、分库分表的情况】
如何建立索引？

查询优化 、慢查询

2.MySQL，今天发现查询速度比昨天慢得多，可能是什么原因造成的？
3.主表命中索引、子表索引也命中，是什么导致查询速度慢的？
4.没有对索引进行修改，什么情况会导致查询变慢？

了解readview吗，与隔离级别的关系是什么
\10. 讲讲慢查询的优化，什么样的字段适合建索引

\12. mysql怎么持久化，binlog和redolog日志的写入机制是什么（不造）

作者：矿大海投王
链接：https://www.nowcoder.com/feed/main/detail/520897be38d54c1ab741d1a79442a5c7?sourceSSR=search
来源：牛客网

# 缓冲池 

通过前面的文章我们已经了解到数据增删改的一个大致过程如下：

- 先从索引中找到数据所在的`表空间ID`以及在表空间中的数据页的`页号`
- 然后通过`表空间ID+页号`作为Key，去`缓存页哈希表`中查找`Buffer Pool`是否已经加载了这个缓存页。如果已经加载了缓存页，就直接读取这个缓存页。
- 如果没有这个缓存页，就需要从磁盘表空间中加载数据页到内存，此时需要从`Free链表`获取一个空闲页加入`LRU链表`中，加载的数据页就会放到这个空闲的缓存页中。
- 接着在对应的缓存页中执行增删改操作，被修改过的缓存页就变成了脏页，会加入`Flush链表`中。
- 最后，后台线程会在一些时机将`LRU链表`尾部的冷数据和`Flush链表`中的脏页刷盘。

在 MySQL 启动的时候，**InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的`16KB`的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页**。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。
