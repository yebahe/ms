# 0、讲一下面向对象的理解

**对象就是对事物的一种抽象描述。**

万物皆对象。那么也就是说我们现实生活中只要是物体，都能用对象来表示！那么也就是说我们可以用Java类去模拟现实事物，用Java类去描述一个对象。

  现实世界中的事物，都可以用【属性】和【能力】来描述。在Java中，将具有相同属性和能力的事物归为**类**，属性称为类的属性，能力称为类的方法 ，对象就是类的实例。

将具体的功能封装于类中，通过类来创建对象，让对象调用方法来实现具体的功能。这种编程思想称为面向对象编程。【比如 

**面向对象的特点主要可以概括为封装性、继承性和多态性**。

# 1、面向对象和面对过程的区别

两者的**主要区别**在于**解决问题的方式不同**：

- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

# 2、面向对象三大特征

## 封装

将对象的信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。 例如Java中会将属性设置为private封装在对象内部，对外提供get和set方法对内部的信息进行访问。



## 继承

继承是 让一个类（称为子类或派生类）获得另外一个类（称为父类或基类）的属性和方法的机制。通过继承，子类可以复用父类的代码，扩展父类的功能，并且可以形成类之间的层次关系。

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**【new的时候，会分配内存】。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（重写）。

------



## 多态

https://baijiahao.baidu.com/s?id=1762140932760303214&wfr=spider&for=pc

**理解 ：**

- **同一个类型的对象在不同的情况下表现出不同的行为。**【多个对象调用同一个方法，得到不同的结果。】
- 从而实现了代码复用、提高代码可维护性和可扩展性等目的。多态的实现基于继承和方法重写，以及向上转型和动态绑定等机制，同时还涉及到编译时多态和运行时多态两种实现方式。

**具体表现：**

- 为父类的引用指向子类的实例。当是多态时，该**引用名称**只能访问父类中的属性和方法，但是执行的时候会优先去执行子类重写以后的方法。

> **多态的前提：**
>
> - 子类必须继承父类
> - 子类必须重写父类的方法
> - 父类引用指向子类对象，即：父类类名 引用名称 = new 子类类名();

**对面向对象来说，多态分为编译时多态和运行时多态**。

- **编译时多态是静态的，是指在编译时就确定了调用哪个方法，它是根据参数列表的不同来区分不同的方法。**通过编译之后会变成两个不同的方法，在运行时谈不上多态。主要是指方法的重载
- **而运行时多态是动态的，它是通过动态绑定来实现的，在程序运行时根据对象的实际类型来决定调用哪个方法**，比如方法的重写。

> 向上转型是指将一个子类对象赋值给一个父类引用变量的过程，这样就可以实现父类引用变量调用子类对象的方法。
>
> 动态绑定是指在程序运行时根据对象的实际类型来确定调用哪个方法，这样就可以实现多态。

# 3、重载和重写

## 什么是重载？

重载是指**方法名相同，但是参数列表不同**【个数、顺序，类型 不同】 

**重载可以发生在同一个类的不同方法之间，也可以发生在继承关系中父类和子类的方法之间。**是编译时多态。

- 与权限修饰符、返回值类型无关【权限修饰符、返回值类型不同，但只要方法名相同并且参数列表不同就是重载】

## 什么是重写？

**重写是指在子类中重新定义父类的某个方法**，**方法名和参数列表必须与父类相同**。发生在子父类之间。是运行时多态

子类重写父类的方法，方法名相同并且参数列表相同

- 访问修饰符范围大于等于父类的方法的范围 。

- 子类方法返回类型也必须相同或者是其子类。
  - 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。
  - 如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。
- 抛出的异常范围小于等于父类。

  

**如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法、**

>  （1） private 修饰的方法不能被重写 【子类拥有但是无法访问】
>
>  （2）final 修饰的方法不能被重写
>
>  （3）static 修饰的方法不能被重写【使用`static`关键字修饰的方法属于类级别的方法】

# 4、运行时多态和编译时多态、

**对面向对象来说，多态分为编译时多态和运行时多态**。

- **编译时多态是静态的，是指在编译时就确定了调用哪个方法，它是根据参数列表的不同来区分不同的方法。**通过编译之后会变成两个不同的方法，在运行时谈不上多态。

  主要是指方法的重载

- **而运行时多态是动态的，它是通过动态绑定来实现的，在程序运行时根据对象的实际类型来决定调用哪个方法**，比如方法的重写。

  > 向上转型是指将一个子类对象赋值给一个父类引用变量的过程，这样就可以实现父类引用变量调用子类对象的方法。
  >
  > 动态绑定是指在程序运行时根据对象的实际类型来确定调用哪个方法，这样就可以实现多态。



# 5、 接口

接口是一种引用数据类型。接口中定义了一组抽象方法（abstract）的声明，但是并不给出具体实现，当某个类要使用接口时，再去实现接口中的这些方法。类需要遵从接口中描述的统一规则进行定义。**所以，接口是对外提供的一组规则，标准。**

# 6、抽象类

# 7、接口和抽象类的区别 

**共同点**：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别**：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

------





# 

# 

# 0、值传递

`java`中只有值传递

如果不修改 怎么交换都不会发生变化 ，就算是引用类型的进行交换也是在交换地址，并没有对这片地址中的值进行修改。



#  1、`==` 和`equal`的区别

- == 
  - 对于基本数据类型 【比较的是**值 是否相等**】
  - 对于引用数据类型 【比较的是**引用地址是否相等**】

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。

- **类没有重写 `equals()`方法**：通过`equals()`比较该类的两个对象时，**【等价于通过“==”比较这两个对象】**，使用的默认是 `Object`类`equals()`方法。

  **类重写了 `equals()`方法**：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

  - `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

    当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。



# 2、`String`、`StringBuilder` 和`StringBuffer`的区别

## 2.1 `String`、`StringBuilder` 和`StringBuffer`的区别

- String是不可变的，而`StringBuilder` 和`StringBuffer`是可变的 
- String 是不可变的，可以理解为常量，是线程安全的。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。



## *2.2 String 不可变是什么意思？

String不可变很简单，如下图，给一个已有[字符串](https://www.zhihu.com/search?q=字符串&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A114125846})"abcd"第二次赋值成"abcedl"，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。

String 不可变是指空间不可变 。

![img](https://pica.zhimg.com/46c03ae5abf6111879423f38375207cc_r.jpg?source=2c26e567)

## 2.3 String 为什么不可变 ？

[String类](https://www.zhihu.com/search?q=String类&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A114125846})的主力成员字段value是个char[ ]数组，而且是用**final**修饰的。final修饰的字段创建以后就不可改变。【不允许我把value指向堆区另一个地址】

private final char value[]这一句里，char[]数组的访问权限是私有的，在后面所有String的方法里很小心的没有去动Array里的元素，没有暴露内部成员字段【【保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。】

String类是用final关键字修饰，这说明String不可继承，进而避免了子类破坏 `String` 不可变。

## 2.4 String 和new String



# 3、switch case

**switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断**。【按照代码的顺序，遇到break才会停止】

在使用switch case的时候会先来判断case的值是否满足，满足就执行对应的代码块，如果没有break语句那么当前的case之后的case代码块都会输出，直到执行到break。

# 4、基本数据类型



# 5、包装类

## 自动装箱和自动开箱



# 6、代码的执行顺序



# 7、异常