# JVM



![img](https://img-blog.csdnimg.cn/1d0b04d9458f4b8ab56f76238357c252.png#pic_center)

# 0、介绍一下`JVM`？

`JVM`：`java虚拟机`，虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的，Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。

**`JVM` 屏蔽了与具体操作系统平台相关的信息**，使 `Java 程序`只需生成在 `Java 虚拟机上`运行的目标代码 （字节码），把`.class文件`**解释成各个平台可以识别的机器码**，最终实现跨平台运行代码。

整体上可以分成三个部分：类加载子系统、执行引擎、运行时数据结构，【本地方法接口】

# 1、JVM 在哪里？

JVM运行在操作系统上

## **JVM 的主要作用是什么？**

JVM 屏蔽了**具体操作系统平台相关的信息**，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码 （字节码），生成各个平台可以识别的机器码，就可以在不同的平台上运行。

# 2、JVM的整体结构 

主要由 **类加载子系统、执行引擎、运行时数据结构** 



# 1、[类加载器](https://so.csdn.net/so/search?q=类加载器&spm=1001.2101.3001.7020)子系统

## 1.1 类加载器子系统的作用

`java`编译后生成的**`.class文件`**（字节码文件），需要在`JVM`的类加载子系统处理下加载到内存中。
**类加载子系统负责将字节码文件加载到内存中，生成大写的Class实例对象，存储在方法区中。**

加载后是否能正常的执行，需要`JVM`另一个结构执行引擎决定。

![https://camo.githubusercontent.com/a24bb36fa9daa4ca1e47137fb5b92c3545147cf2050c0528de7a84f86453264c/68747470733a2f2f696d616765732d313330313132383635392e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f4d6163426f6f6b50726f3230323230383035313431353538342e706e67](https://camo.githubusercontent.com/a24bb36fa9daa4ca1e47137fb5b92c3545147cf2050c0528de7a84f86453264c/68747470733a2f2f696d616765732d313330313132383635392e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f4d6163426f6f6b50726f3230323230383035313431353538342e706e67)

————————————————————————————————————————————————

## 1.2 类加载机制是什么

Java虚拟机把<u>描述类的数据</u>**从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的`Java.lang.Class`类型**，这个过程被称作`jvm`的类加载机制。

## 1.3 [类加载的时机](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/01-类加载子系统.md#类加载的时机)



##  1.4 类加载的过程

类加载的生命周期 ：加载，链接，初始化，使用，卸载

**类加载的过程主要分为三个阶段 加载，链接，初始化**。 而**链接阶段又可以细分为验证，准备，解析三个子阶段。**

接下来，我们详细分析下类加载的过程。

### [加载过程](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#加载过程)

加载过程需要完成以下三个事情:

- 通过一个类的`全限定名`获取定义此类的`二进制字节流`；
- 将这个字节流所代表的的`静态存储结构`转化为方法区的`运行时数据结构`；
- **在内存中生成一个代表这个类的`java.lang.Class对象`，作为方法区这个类的各种`数据的访问入口`**

加载这一步主要是**类加载器** 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。

每个 Java 类都有一个引用指向加载它的 `ClassLoader`。不过，数组类不是通过 `ClassLoader` 创建的，而是 `JVM` 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 `ClassLoader` 的时候和该数组的元素类型的 `ClassLoader` 是一致的。

------



### [链接过程](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#链接过程)

（[验证(Verify)](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#验证verify)--->[准备(Prepare)](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#准备prepare)--->[解析(Resolve)](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#解析resolve)）

**[验证(Verify)](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#验证verify)**

[1. 目的:](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#1-目的)  **在于确保Class文件的字节流中包含信息符合当前`JVM`规范要求，保证被加载类的正确性，不会危害虚拟机自身安全**。

[2. 主要包括四种验证](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#2-主要包括四种验证)

文件格式验证

> - `文件格式验证`
>
>   - 字节码是否以十六进制的`CAFEBABE`开头
>   - 主，次版本号是否在当前虚拟机可接受的范围之内。
>   - 常量池的常量中是否有不被支持的类型
>   - Class文件中是否有被添加的其他恶意信息。
>
>   文件格式验证不止以上，上面所列举的只是从HotSpot虚拟机源码中摘抄的一部分。只有通过这个阶段的验证之后，这一段字节流才会进入虚拟机内存中进行存储， 之后的过程都是基于方法区中的存储结构进行的。不会直接读取字节流了。
>
> - `源数据验证`
>
>   用于保证字节码中的代码符合《Java语言规范》
>
>   - 此类的父类是否是不可继承的类（Final修饰的）
>   - 如果此类不是抽象类，它是否实现了全部需要实现的方法。
>   - 类中的字段，方法是否和父类冲突。
>   - ……
>
> - `字节码验证`
>
>   此过程保证代码是符合逻辑的，对代码的流程进行判断，保证不会出现危害虚拟机安全的情况。
>
>   - 保证任意时刻操作数栈中的类型和指令代码序列可以正常工作，比如执行到iadd字节码指令，但是操作数栈顶有一位是Long类型的。
>   - 保证代码中的类型转换是有效的。
>
>   如果一个类型中的方法体没有通过次阶段，那它一定是有问题的。但是，不可以认为只要通过此阶段验证，一定没有问题。通过程序去校验程序的逻辑是无法做到绝对准确的。
>
> - `符号引用验证`。
>
>   此阶段验证符号引用是否合法，主要用于解析阶段的前置任务。
>
>   主要用于判断 该类中是否存在缺少后者被禁止访问它依赖的某些外部类，字段，方法等资源。

[准备(Prepare)](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#准备prepare)

- 为类变量（static）分配内存并且设置初始值。【**是在方法区中分配的内存===> jdk1.7之前是在永久代中，而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中**】
- **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；**
- **不会为实例变量分配初始化，类变量会分配在方法区/堆中，而实例变量是会随着对象一起分配到`java`堆中。**

[解析(Resolve)](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#解析resolve)

- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，**也就是得到类或者字段、方法在内存中的指针或者偏移量**

### [初始化过程](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/02-类加载过程.md#初始化过程)

初始化阶段就是执行类构造器方法`clInit()`的过程。

- 在初始化阶段，类的<clinit>方法（类构造器方法）会执行，**这个方法负责完成静态成员变量的初始化以及执行静态代码块**

#### 必须对类进行初始化的情况

对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：

1. 当 jvm 执行 `new` 指令时会初始化类。即当程序创建一个类的实例对象。

   程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。

   程序给类的静态变量赋值。

   程序调用类的静态方法。

2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。

3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。

------

 

## 1.5 类加载器

### 类加载器介绍

`ClassLoader` 是一个抽象类。**类加载器是一个负责加载类的对象**。

加载这一步主要是**类加载器** 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。

每个 Java 类都有一个引用指向加载它的 `ClassLoader`。不过，数组类不是通过 `ClassLoader` 创建的，而是 `JVM` 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 `ClassLoader` 的时候和该数组的元素类型的 `ClassLoader` 是一致的。

**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 `JVM` 中（在内存中生成一个代表该类的 `Class` 对象）**

### 类加载器加载规则

`JVM` 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，对于已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。

### 类加载器总结

JVM 中内置了三个重要的 `ClassLoader`：

1. **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，**主要用来加载 JDK 内部的核心类库**（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2. **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

除此之外，我们还可以自定义类加载器

------



## 1.6 双亲委派机制

### 介绍一下双亲委派机制

​		Java虚拟机对class文件采用的是按需加载的方式，

​		也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象。

​		而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式。

​		即

- **[如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行]**
- [如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。]
- [如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载。直到加载成功。]

### [双亲委派机制优势](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/05-双亲委派机制.md#双亲委派机制优势)

- 避免类的重复加载

  （JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）

- 保护程序安全，防止核心API被随意篡改

  比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现两个不同的 `Object` 类。双亲委派模型可以保证加载的是 JRE 里的那个 `Object` 类，而不是你写的 `Object` 类。这是因为 `AppClassLoader` 在加载你的 `Object` 类时，会委托给 `ExtClassLoader` 去加载，而 `ExtClassLoader` 又会委托给 `BootstrapClassLoader`，`BootstrapClassLoader` 发现自己已经加载过了 `Object` 类，会直接返回，不会去加载你写的 `Object` 类。

  ------

  

## [1.7 沙箱安全机制](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/06-沙箱安全机制.md#一沙箱安全机制)

[ 定义:](https://github.com/Programming-With-Love/JVMStudy/blob/main/01-类加载子系统/06-沙箱安全机制.md#1定义)

比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现两个不同的 `Object` 类。双亲委派模型可以保证加载的是 `JRE` 里的那个 `Object` 类，而不是你写的 `Object` 类。这是因为 `AppClassLoader` 在加载你的 `Object` 类时，会委托给 `ExtClassLoader` 去加载，而 `ExtClassLoader` 又会委托给 `BootstrapClassLoader`，`BootstrapClassLoader` 发现自己已经加载过了 `Object` 类，会直接返回，不会去加载你写的 `Object` 类。                                       

自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载， 而引导类加载器在加载过程中会先加载`jdk`自带的文件（`rt.jar`包中的`java\lang\String.class`）, 报错信息说没有main方法就是因为加载的是`rt.jar`包中的String类。 这样可以保证对`java`核心源代码的保护，这就是沙箱安全机制.



# 2、运行时数据区域、JVM内存结构（java内存区域）

## 1.1 程序计数器

线程私有的，是一块很小的内存空间，**指向下一条要执行的指令**

作用 ：**（1）**指向下一条要执行的指令,从而实现代码的流程控制

​			**（2）**多线程情况下，可以根据pc寄存器找到线程切换前的执行位置【当线程切换时，操作系统会保存当前线程的上下文信息，包括程序计数器的值。当线程重新获得执行时间时，操作系统会恢复该线程的上下文信息，包括程序计数器的值。这样，线程就能够继续执行之前中断的位置】

- 不会发生OOM【它的生命周期随着线程的创建而创建】

## 1.2 虚拟机栈

是线程私有的，随着线程的创建而分配内存、随着线程的死亡而销毁，

java中除了用native 修饰的方法外其他的方法的调用都需要通过栈来实现。栈是由一个个栈帧组成的，每一个方法都是一个栈帧，每个栈帧有局部变量表、操作数栈、方法返回值地址等。调用方法时栈帧入栈，方法完成栈帧出栈。

- **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。

- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

## 1.3 本地方法栈

执行native 修饰的方法需要通过本地方法栈来实现，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

## 1.4 方法区

是各个线程共享的内存区域，用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域

方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**

jdk1.8以及之后是将字符串常量池、静态变量等都移到了堆中

### 方法区的落地实现：

1.7  ： 永久代

1.8 ： 元空间

### 永久代和元空间的区别

- 永久代使用是JVM的内存、大小是固定的无法动态调整，而元空间是JVM调用操作系统分配的一块本地内存，内存大小可以动态调整，这样的话就可以加载更多的类了【但是仍然会出现OOM】

## 1.5 堆

Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。

**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

### 堆空间的基本结构

1.7 以及之前 堆内存**逻辑上**分为： 新生区，养老区，永久代

1.8 以及之后 堆内存**逻辑上**分为： **新生区（1/3），养老区（2/3）**，元空间

**新生区又分为伊甸区（8/10）、幸存0区（from区.1/10）、幸存1区（to区2/10）**

### 堆空间为什么要划分？

更好地进行垃圾回收、更快地分配内存

### 堆空间的作用

**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

几乎所有对象 ： **未逃逸出来的对象直接在栈里面分配内存**（如果方法中的对象引用未被返回或者未在方法外被使用）

### **对象内存分配原则：**

 对象优先在堆中分配内存、**几乎所有的对象实例以及数组都在这里分配内存。**

如果某些方法中的对象引用没有被返回或者未被外面使用（也就是**未逃逸出去**），那么对象可以直接在栈上分配内存。**线程本地缓冲区(TLAB)**

栈上分配->TLAB->新生代->老年代

**对象内存分配原则有**

**（1）对象优先在 Eden 区分配**

- 大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。【这是对伊甸区和from区进行的垃圾回收，对`eden`和`S1`的对象进行可达性分析，销毁失去引用的对象，同时将剩下的对象全部移动到另一个幸存者区`S2`（to），并清空`eden`和`S1`（from）。存活的对象分代年龄 +1 ，分代年龄)】。如果Survivor无法容纳这些存活的对象，则只有通过分配担保机制将这些存活对象提前移动到老年代中，然后将要分配的对象分配到Eden区中。

**（2）大对象直接进入老年代**

- 大对象就是需要连续的大量内存空间，最典型的就是字符串或者数组。可以设置-XX:PretenureSizeThreshold参数，当大于这个值的对象直接会在老年代中分配，避免了在Eden区和两个Survivor之间大量的拷贝

**（3）长期存活的对象将进入老年代**

- 虚拟机中每个对象都是有年龄的，对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象  年龄设为1岁。**对象在Survivor区中每熬过一次Minor  GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中**。对象晋升老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`设置。 

**（4）动态判断分代年龄**

虚拟机并不是严格按照对象年龄阀值`-XX:MaxTenuringThreshold`来判断是否可以晋升老年代，而是会通过动态对象年龄判断。所谓的动态对象年龄判断就是 **把Survivor区中的所有对象，从年龄为1的对象开始计算其大小，一直累加到年龄为n的对象，假如累加到年龄n的时候大于等于Survivor区的一半，那么就会把年龄大于等于n的对象全部移到老年代**

### **（5）空间担保机制**

- 在发生Minor  GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，
  - 如果这个条件成立，那这一次Minor  GC可以确保是安全的。
  - 如果不成立，则虚拟机会先查看-  XX:HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion  Failure）；
    - 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
      - 如果大于，将尝试进行一次Minor  GC，尽管这次Minor  GC是有风险的；
      - 如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
- JDK 6之后规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行Full GC。**

# 

## ------------------------------------------------------------------------------------------

## 1.6 运行时常量池

- 运行时常量池是当Class文件被加载到内存后，Java虚拟机会 **将Class文件常量池表里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)**

- 运行时常量池包含了编译期生成的各种字面量（如字符串、数字、布尔值等）以及对类、方法和字段的符号引用。

## 1.7 字符串常量池？





# 3、对象的创建

**（1）判断对象对应的类是否加载** 

当虚拟机接收到一条new指令的时候，会先去方法区【永久代/元空间】运行时常量池中查找是否存在该类的符号引用，判断是否已经经过了加载、链接、初始化。

如果没有的话：就在双亲委派的模式下，加载该对象对应的类【这里就是类的加载过程，注意这里可能会找不到该对象对应的.class文件,那就直接抛出异常】

如果已经加载的话，就直接进入到为类对象内存分配

**（2）为类对象内存分配**

在堆空间中为类对象分配一块内存空间。

分配方式有 指针碰撞和空闲列表===========选用那种方式取决于堆中垃圾回收算法

指针碰撞： 

- 适用场合：堆内存规整（即没有内存碎片）的情况下。
- 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
- 使用该分配方式的 GC 收集器：Serial, ParNew

空闲列表： 

- 适用场合：堆内存不规整的情况下。
- 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
- 使用该分配方式的 GC 收集器：CMS



因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配



**（3）初始化默认值**

**（4）设置对象头**

对象头分配两部分 ：`Markword` 和`classpoint` 

`markword` 中记录的信息有：对象的`hashcode` 、锁标志位，分代年龄

`classpoint` 指针指向方法区中的类元信息

 **（5）执行`init（）`方法进行初始化**

行 new 指令之后会接着执行 `init` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来



# 4、对象内存分配原则 

https://www.zhihu.com/tardis/zm/art/458206149?source_id=1003

 对象优先在堆中分配内存、**几乎所有的对象实例以及数组都在这里分配内存。**

如果某些方法中的对象引用没有被返回或者未被外面使用（也就是**未逃逸出去**），那么对象可以直接在栈上分配内存。**线程本地缓冲区(TLAB)**

栈上分配->TLAB->新生代->老年代

**对象内存分配原则有**

**（1）对象优先在 Eden 区分配**

- 大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。【这是对伊甸区和from区进行的垃圾回收，对`eden`和`S1`的对象进行可达性分析，销毁失去引用的对象，同时将剩下的对象全部移动到另一个幸存者区`S2`（to），并清空`eden`和`S1`（from）。存活的对象分代年龄 +1 ，分代年龄)】。如果Survivor无法容纳这些存活的对象，则只有通过分配担保机制将这些存活对象提前移动到老年代中，然后将要分配的对象分配到Eden区中。

**（2）大对象直接进入老年代**

- 大对象就是需要连续的大量内存空间，最典型的就是字符串或者数组。可以设置-XX:PretenureSizeThreshold参数，当大于这个值的对象直接会在老年代中分配，避免了在Eden区和两个Survivor之间大量的拷贝

**（3）长期存活的对象将进入老年代**

- 虚拟机中每个对象都是有年龄的，对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象  年龄设为1岁。**对象在Survivor区中每熬过一次Minor  GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中**。对象晋升老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`设置。 

**（4）动态判断分代年龄**

虚拟机并不是严格按照对象年龄阀值`-XX:MaxTenuringThreshold`来判断是否可以晋升老年代，而是会通过动态对象年龄判断。所谓的动态对象年龄判断就是 **把Survivor区中的所有对象，从年龄为1的对象开始计算其大小，一直累加到年龄为n的对象，假如累加到年龄n的时候大于等于Survivor区的一半，那么就会把年龄大于等于n的对象全部移到老年代**

**（5）空间担保机制**

- 在发生Minor  GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，
  - 如果这个条件成立，那这一次Minor  GC可以确保是安全的。
  - 如果不成立，则虚拟机会先查看-  XX:HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion  Failure）；
    - 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
      - 如果大于，将尝试进行一次Minor  GC，尽管这次Minor  GC是有风险的；
      - 如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
- JDK 6之后规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行Full GC。**

# 5、垃圾回收

## 1、什么是垃圾（ Garbage） 呢？

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

## 2、怎么判断对象是否要回收？

**对象称为垃圾的依据**

判断对象存活一般有两种方式 ：引用计数算法 和 可达性分析法

### 1、引用计数算法

为每个对象都设置一个整型的变量作用计数器，但有一地方引用了该对象，计数器就+1，当引用失效计数器就-1，当计数器为0的时候就认为该对象不再被使用，就认为该对象是垃圾，可以被回收。

优缺点：

优点： 实现起来比较简单

缺点 ：很难解决对象之间循环引用的问题

### 2、可达性分析法

设置一些对象为GC roots，从这些节点往下搜索，如果该对象到GC roots不存在路径（引用链），就认为该对象不再被使用，可以被回收。

#### ***哪些对象可以认为是GC roots ？***

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

### **3、对象可以被回收，就代表一定会被回收吗？**



### 4、在确定了哪些对象可以被回收之后，jvm会在什么时候进行回收

（1）cpu空闲的时候

（2）堆内存满了，JVM会触发垃圾回收来释放无用对象占用的内存空间，以便为新对象提供足够的内存空间。

（3）调用System.gc()的时候

## 3、垃圾回收算法的类型

### **1、标记清除算法**

jvm在回收之前，会先通过**可达性算法来标识存活对象**，然后再进行线性搜索清除未被标识的对象。

**优点：**简单

**缺点：**效率低（两次遍历操作）、会产生大量的内存碎片【分配较大对象时无法找到足够的连续内存而造成内存空间浪费。】



### 2、复制算法

将内存分成两个大小相等的区域，只使用其中的一块区域，在标记阶段先通过**可达性算法来遍历确定存活对象，将存活对象**复制**到另外一个区域，**然后**再把已使用过的内存空间一次清理掉**。  

优点： 实现简单，运行高效，不会导致内存随便

缺点： 内存减半。如果内存中存活对象很多则不适合这个算法

### 3、标记整理算法

先通过可达性算法来确定存活对象，并且移动存活对象到内存的一端，遍历结束之后再来清理（有一个指针指向最后一个存活对象）

### 4、分代清除算法

当前垃圾收集都是采用这种算法。主要将Java堆分为年轻代和老年代，根据不同的年代采用不同的算法。在新生代中，由于只有少量的存活对象，此时就使用“复制”算法；在老年代中，由于存活对象比较长没有额外空间进行分配担保，就使用“标记-整理”或“标记-清理”算法。

新生代 ：复制算法

老年区 ： 标记清除算法 、标记压缩算法

分代收集算法大致过程：

1. JVM新创建的对象会放在`eden`区域。
2. 当`eden`区域快满时，触发`Minor GC`新生代GC，通过可达性分析将失去引用的对象销毁，剩下的对象移动到幸存者区`S1`，并清空`eden`区域，此时`S2`是空的。
3. 当`eden`区域又快满时，再次触发`Minor GC`，对`eden`和`S1`的对象进行可达性分析，销毁失去引用的对象，同时将剩下的对象全部移动到另一个幸存者区`S2`，并清空`eden`和`S1`。
4. 每次`eden`快满时，重复上述第3步，触发`Minor GC`，将幸存者在`S1`与`S2`之间来回倒腾。
5. 在历次`Minor GC`中一直存活下来的幸存者，或者太大了会导致新生代频繁`Minor GC`的对象，或者`Minor GC`时幸存者对象太多导致`S1`或`S2`放不下了，那么这些对象就会被放到老年代。
6. 老年代的对象越来越多，最终会触发`Major GC`或`Full GC`，对老年代甚至整堆的对象进行清理。通常`Major GC`或`Full GC`会导致较长时间的`STW`，暂停GC以外的所有线程，因此频繁的`Major GC`或`Full GC`会严重影响JVM性能。



# 4、总结一下有哪些情况可能会触发 JVM 进行 Full GC。

1. **`System.gc()` 方法的调用   **此方法的调用是**建议 JVM 进行 Full GC**，注意这**只是建议而非一定**，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 `System.gc()`。
2. **空间担保失败**   ：老年代的**连续空间**小于新生代对象总大小并且小于历次晋升的平均大小
3. **老年代空间不足**  老年代空间不足会触发 Full GC 操作，若进行该操作后空间依然不足，则会抛出如下错误：`java.lang.OutOfMemoryError: Java heap space`
   - 老年代空间不足的常见场景 ： 比如大对象、大数组直接进入老年代、长期存活的对象进入老年代等。
4.  **JDK 1.7** **及以前的（永久代）空间满**