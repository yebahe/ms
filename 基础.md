# 基础

# 1、 基本数据类型和引用数据类型

# 1.1 、8种基本数据类型

short（16） 、int（32） 、long（64） 、double（64） 、float（32）、boolean 、byte（8）、char（16）

# 1.2、 8种基本数据类型对应的包装类

   

# 1. 3、自动装箱 和自动拆箱

装箱：将基本数据类型变为包装类对象。
拆箱：将包装类中包装的基本数据类型取出

自动装箱：Integer i = 10;

自动拆箱：int n=i;

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`;



# 1.4、 包装类是什么？为什么需要包装类？

包装类它们是一种将基本数据类型（如int、float、boolean等）封装成对象的机制。

- Java是面向对象的编程语言，而基本数据类型（如int、float、boolean等）并不是对象。为了能在面向对象的环境中使用这些基本数据类型，需要将它们包装成对象。

  （1）Java的集合类（如List、Set、Map等）只能存储对象而不能存储基本数据类型。通过使用包装类，可以将基本数据类型转换为对象，从而在集合类中存储它们。

  （2） 包装类可以表示空值（null），而基本数据类型不能。



# 1.5 包装类对象数据存储在哪里

如果对象的值范围在[-128,127] 那么数据是存储在缓存池中。

如果数据超过了这个范围，那么会在堆里面开辟一块内存空间。

#  1.6 == 和equal

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。

- **类没有重写 `equals()`方法**：通过`equals()`比较该类的两个对象时，**【等价于通过“==”比较这两个对象】**，使用的默认是 `Object`类`equals()`方法。

  **类重写了 `equals()`方法**：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

  - `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

    当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。

    ------

    

  



# 2、代码的执行顺序：

- 执行init方法才会执行静态代码块、不同final修饰的静态变量

***一个类的情况：***

（1）静态代码块、静态变量 按照代码顺序执行 【类加载中初始化的过程】===> 

​		普通代码块、普通变量按照代码顺序执行【创建对象的过程】====>

​		构造函数     ====> 调用的方法

***继承的情况***

（2）父类中静态代码块、静态变量 按照代码顺序执行 【类加载中初始化的过程】==>

​		子类中静态代码块、静态变量 按照代码顺序执行【类加载中初始化的过程】===>

​		父类普通代码块、普通变量按照代码顺序执行【创建对象的过程】====>父类构造函数     ====>

​		子类普通代码块、普通变量按照代码顺序执行【创建对象的过程】====>子类构造函数

**类加载中初始化的过程是不一定会执行的**

## **2、类加载的初始化过程（clinit方法）执行的情况如下 **

（0）初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

（1）**主动创建对象【new 、反射】** {子类、父类都会被加载并且都会初始化阶段 ---执行到构造方法}

（2）**调用子类的静态方法、不用final修饰的静态属性**{（**子类、父类的类加载的初始化过程执行）**}

- 子类调用父类的静态方法、不用final修饰静态属性{父类的类加载的初始化过程执行，子类会被加载，但是初始化不会被执行}
- 不管是调用子类还是父类的用final修饰的静态属性 {子类、父类的类加载的初始化过程都不会执行}

（3）当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类



## 3、面向对象的三大特征

封装、继承、多态

### 封装

#### 1、什么是封装

封装就相当于把不需要用户了解的细节隐藏起来，只对外提供公共的访问方式。

通俗一点来说就是把**类中的某些信息进行隐藏，从而使外部程序不能直接对这些信息进行直接的访问，只能通过类中定义的方法 对这些隐藏的信息进行操作和访问**。现在主要是对属性进行封装，对方法进行封装的比较少 见。例如 属性私有，使用get/set方法访问这些属性。

### 继承

#### 1、什么是继承？

继承是使用已存在的类作为基础建立新类的技术，这个已经存在的类通常描述了一类对象的通用特征和行为，称为父类，建立新类称为子类。

继承让一个类（称为子类或派生类）获得父类（称为父类或基类）的属性和方法的机制。通过继承，子类可以复用父类的代码，扩展父类的功能，并且可以形成类之间的层次关系。

> 不同类型的对象，相互之间经常有一定数量的共同点，把这些共同点抽取出来形成一个类，使用这个被抽取出来的已存在的类作为基础建立新类的技术叫做继承，这个新的类继承了那个被抽取出来的已存在的类，新类的定义可以增加新的数据或新的功能同时也拥有父（基类)类的所有属性和方法，
>

- 它主要解决的问题是：共性的抽取，实现代码复用。

- 特点 ：（1）子类拥有父类的所有属性和方法，但是子类不能访问父类中私有的属性和方法【不能访问但是拥有】

  ​				![image-20230722145012543](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230722145012543.png)

  ​        （2）子类拥有自己的属性和方法，即对父类的拓展。

  ​		（3）子类可以重写父类的方法			

#### 2、构造方法

- 如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认public的不带参数的构造方法。如果自己定义了构造方法，默认的将不复存在。

- **构造方法不能被 override（重**写）,但是可以 overload（重载）

- 调用构造方法时先调用基类的构造方法，在调用子类（**即在子类中隐藏super()** ）

- · 若父类显示定义无参或者默认的构造方法，在子类构造方法的第一行默认有**隐含的super调用**，即调用基类的构造方法

  · 如果父类的构造方法是带有参数的，此时编译器不会给子类生成默认的构造方法，此时需要用户在子类中显示定义构造方法，并在子类构造方法中选取合适的父类构造方法调用

  ![image-20230708154605216](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708154605216.png)



![image-20230708215029309](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708215029309.png)

##### 2.1 super 和this 

this可以理解为一个变量，指向调用方法的对象

![image-20230722151612680](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230722151612680.png)

![image-20230708215426834](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708215426834.png)



在构造方法中 super() 和this.其他构造方法（） 只能显示地出现一个

#### 3、子父类访问规则

###### 成员变量

![image-20230708210835530](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708210835530.png)

- 子类和父类中不存在同名的成员变量【优先访问被重写的，如果子类没有重写那么就访问父类中的属性】
- 子类和父类中存在同名的成员变量【子类将父类同名属性隐藏】
  - 同名并且类型相同
  - 同名但是类型不相同

- 

###### 成员方法





#### 5、 this super、

![image-20230708215426834](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708215426834.png)



#### 4、访问权限

###### private、default、protected、public 修饰属性和方法

private ： 只能在当前类中才能访问到

![image-20230708161611743](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708161611743.png)

default ： 默认包权限【路径权限、相同路径 、子包也不行】，只要在一个包内就能访问到

![image-20230708161712230](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708161712230.png)

protected ： 子类可用





public ： 在哪都能访问到

![image-20230708161943102](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708161943102.png)

![image-20230708162838578](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708162838578.png)





###### 访问权限要区分的两个点 

 要分清楚谁来访问，访问谁

###  多态

#### 1、什么是多态？

多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例

理解： 实体看成是父类，这个类有多个子类

​			 实体看成是接口 ，这个接口有多个实现类

#### 2、运行时多态和编译时多态

编译时多态 ： 在编译的时候就知道要执行的是哪个目标方法【重载】

运行时多态： 在运行的时候才知道要执行的是哪个目标函数【重写】

#### 3、什么是重写？

子类重写父类的方法，方法名相同并且参数列表相同

- 子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类的方法的范围 ，

  - 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。
  - 如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

  

- **如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法、**

  >  （1） private 修饰的方法不能被重写 【子类拥有但是无法访问】
  >
  > （2）final 修饰的方法不能被重写
  >
  > （3）static 修饰的方法不能被重写【使用`static`关键字修饰的方法属于类级别的方法】

  

- **final 修饰的类不能被继承、私有构造函数的类不能被继承**

#### 4、什么是重载

方法名相同，参数列表不同【个数、顺序，类型】与权限修饰符、返回值类型无关【权限修饰符、返回值类型不用，但只要方法名相同并且参数列表不同就是重载】

#### 5、父类引用指向子类对象 访问规则

parent p1 =new child();

编译看左边

运行看右边



#### 6、对象的转型

- 自动类型转化

- 强制类型转化

  ![image-20230708210237223](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708210237223.png)

## **4、外部类**

** protected 、public。不能使用另外两个修饰符**

## 5、内部类：

内部类当成是外部类的属性 

![image-20230708163807758](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708163807758.png)



## 6、单例模式 

## 7、final 

![image-20230708164745684](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708164745684.png)

- final 修饰的变量 ： 一旦初始化后就不可以被修改

![image-20230708164356824](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708164356824.png)

- final修饰的方法 ： 不能被子类重写

- final 修饰的类 ：不可以被继承

- final 不可以修饰构造方法



## 8、抽象 Abstract

- 什么是抽象方法？

   用abstract修饰的方法成为抽象方法

  - **没有方法体、只有声明 ，是一种规范，子类必须要给抽象方法具体的实现。**

- 什么是抽象类

  含有抽象方法的类 就是抽象类

  

  - **抽象类无法直接创建对**象、但是可以子类间接创建对象 
  - 里面的方法不一定是抽象方法 【含有抽象方法的类一定是抽象类，抽象类的方法不一定都是抽象的】
  - 子类继承抽象类，需要重写里面的抽象的方法,或者自己本身就是一个抽象类

  ![image-20230708220144798](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708220144798.png)

## 9、接口

接口 ： 实则就是一组规范，是对行为的规范  

![image-20230722155045623](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230722155045623.png)

![image-20230708221519575](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230708221519575.png)





# 10 、String

### 1、String和字符串

- **用双引号括起来的就是字符串**
- java中没有内置字符串类型，而是在java类中提供了一个类用来操作字符串，这个类就是String
- **每一个字符串都是String类的一个对象**（实例）【String类对象称为不可变字符串】

###### 特点

​			（1）**字符串的内容永不可变**

​			（2）==->正是因为字符串的内容不可变，因此字符串可以共享使用，减少内存消耗。

​			（3）**Java 9 将 `String` 的底层实现由 `char[]` 改成了 `byte[]` **

###### 创建字符串方法

​		构造方法

​		直接创建

![image-20230722183621670](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230722183621670.png)

### 2、String类对象称为不可变字符串这是为什么？

- （1） 存储<u>String 类对象（字符串）</u>的数组是用final修饰的并且访问权限设置为private的，并且没有提供修改字符串的方法
- （2）String类被final修饰导致其不可以被继承，从而避免了子类破坏String的不可性

#### 2.1 为什么要这样设计?

- 不可变字符串可以使得字符串共享【它们可以被缓存，以便在需要时进行重复使用，避免了重复创建，减少了内存的消耗】
- 安全性 
  - 线程安全 ：不可变字符串在多线程下是安全的，因为它不可被修改不需要额外的同步操作来保证线程安全
  - 传递安全 ：字符串的不可变性确保了它们在传递过程中的安全性
- 缓存哈希值：字符串被广泛用作哈希表的键，因此其哈希值的计算频率很高。不可变性允许字符串在首次计算哈希值后缓存它，从而提高后续哈希查找的性能。



#### 2.2 字符串常量池

##### 

##### 2.2.1、字符串常量池的作用

JVM为了提升性能和减少内存消耗，针对字符串专门开辟了一块区域，这块区域就是字符串常量池，主要的目的是**避免字符串的重复创建**。

HotSpot 虚拟机中字符串常量池的实现是 `src/hotspot/share/classfile/stringTable.cpp` ,**`StringTable` 可以简单理解为一个固定大小的`HashTable`** ，容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。



![image-20230722185133866](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230722185133866.png)

![image-20230709152846449](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709152846449.png)

在JDK 1.7之前是在方法区中的，在JDK1.7 以及之后就在堆中



#####   

##### 2.2.2为什么要这么改动

- 在永久代中，字符串常量池的大小是受永久代大小的限制的，并且这个区域很GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。会造成内存的浪费

### 3、底层存储String类对象的数组

- jdk 1.8  是用char数组
- jdk1.9及其以后用的是byte数组

#### 3.1 为什么要这样设计？

跟编码方案有关【"编码"在这里指的是将字符映射为数字表示的过程，以便在计算机系统中表示和处理字符。】

如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下 `byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。

### 4、判断创建了几个字符串对象？



![image-20230709101635442](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709101635442.png)

![image-20230709101923574](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709101923574.png)





###  5、+和拼接（底层操作原理）

###### （1） 字面量拼接 

编译器优化

![image-20230709155343396](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709155343396.png)



###### （2）字符串变量拼接 

只要**+前后**出现**字符串变量**，就会使用StringBuilder中的append()方法

实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

![image-20230709160215868](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709160215868.png)

![image-20230709160415508](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709160415508.png)



###### （3）使用final修饰的字符串变量拼接 

final 修饰的就是常量 "abc"等价效果

> 例如上面的final String s1="a"; 
>
> ​					String s2=s1+"b";  实则就等价为 String s2 ="a"+"b";

##### 5.1 这两种方法的比较

（1）使用 + ： 每个+都会创建一个StringBuffer对象，使用其append()方法和toString()方法

![image-20230709161219836](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709161219836.png)



### String#intern 方法有什么作用?

`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

- 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
- 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。

------



![image-20230709173724277](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709173724277.png)





![image-20230709192719025](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709192719025.png)





## 11 、异 常

### 1、什么是异常

异常： 程序在执行的过程中出现了不正确的情况，最终导致JVM非正常停止

### **2、异常体系** 

> Throwabe  ： 所有异常类的超类 
>
> Error    Exception

 **Exception** ： **<u>*编译期异常*</u>**，在编写代码的时候程序出现的异常

​			**RuntimeException** ：***<u>运行期异常</u>***，java程序运行过程中出现的异常

**Error** ：错误 必须修改源代码来解决



### 3、异常产生的原因和处理的过程

![image-20230709211847660](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709211847660.png) 

### 4、处理异常（Exception ）的方法

###### （1）抛出异常 （throws）   

![image-20230709213016419](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709213016419.png)

###### （2）try Catch finally

![image-20230709214000790](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709214000790.png)



![image-20230709214320177](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709214320177.png)

#### 4.1 throw

![image-20230709213103654](C:\Users\16055\AppData\Roaming\Typora\typora-user-images\image-20230709213103654.png)